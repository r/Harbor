<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Harbor E2E Test Runner</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 20px;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
    }
    h1 { margin-bottom: 20px; color: #4fc3f7; }
    .test-suite { margin-bottom: 30px; }
    .test-suite h2 { 
      font-size: 16px; 
      color: #aaa; 
      margin-bottom: 10px;
      border-bottom: 1px solid #333;
      padding-bottom: 5px;
    }
    .test {
      padding: 8px 12px;
      margin: 4px 0;
      border-radius: 4px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .test.pass { background: #1b5e20; }
    .test.fail { background: #b71c1c; }
    .test.pending { background: #333; }
    .test.running { background: #0d47a1; }
    .test-name { flex: 1; }
    .test-time { font-size: 12px; color: #888; }
    .status-icon { width: 20px; text-align: center; }
    .summary {
      margin-top: 20px;
      padding: 15px;
      background: #252540;
      border-radius: 8px;
    }
    .summary.all-pass { border: 2px solid #4caf50; }
    .summary.has-fail { border: 2px solid #f44336; }
    .error-details {
      margin-top: 5px;
      padding: 8px;
      background: #1a1a1a;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      color: #ff8a80;
      white-space: pre-wrap;
    }
    #progress {
      margin-bottom: 20px;
      padding: 10px;
      background: #252540;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <h1>üö¢ Harbor E2E Test Runner</h1>
  
  <div id="progress">Initializing tests...</div>
  
  <div id="results"></div>
  
  <div id="summary" class="summary" style="display: none;"></div>

  <script type="module">
    // Test framework
    const results = [];
    let currentSuite = null;
    
    function log(msg) {
      console.log(`[E2E] ${msg}`);
    }
    
    function updateProgress(msg) {
      document.getElementById('progress').textContent = msg;
    }
    
    function renderResults() {
      const container = document.getElementById('results');
      let html = '';
      
      const suites = {};
      for (const r of results) {
        if (!suites[r.suite]) suites[r.suite] = [];
        suites[r.suite].push(r);
      }
      
      for (const [suite, tests] of Object.entries(suites)) {
        html += `<div class="test-suite"><h2>${suite}</h2>`;
        for (const t of tests) {
          const icon = t.status === 'pass' ? '‚úì' : t.status === 'fail' ? '‚úó' : t.status === 'running' ? '‚è≥' : '‚óã';
          html += `
            <div class="test ${t.status}">
              <span class="status-icon">${icon}</span>
              <span class="test-name">${t.name}</span>
              ${t.duration ? `<span class="test-time">${t.duration}ms</span>` : ''}
            </div>
            ${t.error ? `<div class="error-details">${t.error}</div>` : ''}
          `;
        }
        html += '</div>';
      }
      
      container.innerHTML = html;
    }
    
    async function renderSummary() {
      const passed = results.filter(r => r.status === 'pass').length;
      const failed = results.filter(r => r.status === 'fail').length;
      const total = results.length;
      const failures = results.filter(r => r.status === 'fail').map(r => ({
        suite: r.suite,
        name: r.name,
        error: r.error
      }));
      
      const summary = document.getElementById('summary');
      summary.style.display = 'block';
      summary.className = `summary ${failed > 0 ? 'has-fail' : 'all-pass'}`;
      summary.innerHTML = `
        <strong>${failed === 0 ? '‚úì All tests passed!' : `‚úó ${failed} test(s) failed`}</strong><br>
        ${passed} passed, ${failed} failed, ${total} total
      `;
      
      // Log final results for CI capture
      log(`RESULTS: ${passed} passed, ${failed} failed, ${total} total`);
      if (failed === 0) {
        log('STATUS: PASS');
      } else {
        log('STATUS: FAIL');
      }
      
      // POST results back to test server
      try {
        await fetch('/__test_results__', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ passed, failed, total, failures })
        });
        log('Results posted to test server');
      } catch (err) {
        log('Failed to post results to server: ' + err.message);
      }
    }
    
    async function test(suite, name, fn) {
      const testResult = { suite, name, status: 'running', error: null, duration: null };
      results.push(testResult);
      renderResults();
      
      const start = Date.now();
      try {
        await fn();
        testResult.status = 'pass';
        testResult.duration = Date.now() - start;
        log(`PASS: ${suite} > ${name} (${testResult.duration}ms)`);
      } catch (err) {
        testResult.status = 'fail';
        testResult.duration = Date.now() - start;
        testResult.error = err.message || String(err);
        log(`FAIL: ${suite} > ${name} - ${testResult.error}`);
      }
      renderResults();
    }
    
    function assert(condition, message) {
      if (!condition) {
        throw new Error(message || 'Assertion failed');
      }
    }
    
    function assertEqual(actual, expected, message) {
      if (actual !== expected) {
        throw new Error(message || `Expected ${expected} but got ${actual}`);
      }
    }
    
    // Wait for extensions to inject APIs
    async function waitForAPIs(timeout = 10000) {
      const start = Date.now();
      while (Date.now() - start < timeout) {
        if (typeof window.ai !== 'undefined' && typeof window.agent !== 'undefined') {
          return true;
        }
        await new Promise(r => setTimeout(r, 100));
      }
      return false;
    }
    
    // ============================================================
    // TEST SUITES
    // ============================================================
    
    async function runTests() {
      log('Starting E2E tests...');
      updateProgress('Waiting for extension APIs...');
      
      // Wait for APIs to be injected
      const hasAPIs = await waitForAPIs(15000);
      
      if (!hasAPIs) {
        await test('Setup', 'Extension APIs available', async () => {
          throw new Error('window.ai and window.agent not found. Are the extensions installed?');
        });
        await renderSummary();
        return;
      }
      
      updateProgress('Running tests...');
      
      // ---- Extension Detection ----
      await test('Extension Detection', 'window.ai is defined', async () => {
        assert(typeof window.ai !== 'undefined', 'window.ai should be defined');
      });
      
      await test('Extension Detection', 'window.agent is defined', async () => {
        assert(typeof window.agent !== 'undefined', 'window.agent should be defined');
      });
      
      await test('Extension Detection', 'window.ai has createTextSession', async () => {
        assert(typeof window.ai.createTextSession === 'function', 
          'window.ai.createTextSession should be a function');
      });
      
      await test('Extension Detection', 'window.ai has providers', async () => {
        assert(typeof window.ai.providers === 'object', 
          'window.ai.providers should be an object');
        assert(typeof window.ai.providers.list === 'function',
          'window.ai.providers.list should be a function');
      });
      
      await test('Extension Detection', 'window.agent has tools', async () => {
        assert(typeof window.agent.tools === 'object',
          'window.agent.tools should be an object');
        assert(typeof window.agent.tools.list === 'function',
          'window.agent.tools.list should be a function');
      });
      
      await test('Extension Detection', 'window.agent has run', async () => {
        assert(typeof window.agent.run === 'function',
          'window.agent.run should be a function');
      });
      
      await test('Extension Detection', 'window.agent has requestPermissions', async () => {
        assert(typeof window.agent.requestPermissions === 'function',
          'window.agent.requestPermissions should be a function');
      });
      
      // ---- Provider API ----
      await test('Provider API', 'can list providers (may need permission)', async () => {
        try {
          const providers = await window.ai.providers.list();
          assert(Array.isArray(providers), 'providers.list() should return an array');
          log(`Found ${providers.length} providers: ${providers.map(p => p.name || p.id).join(', ')}`);
        } catch (err) {
          // Permission denied is expected if not granted in test environment
          if (err.message && (err.message.includes('ermission') || err.message.includes('denied'))) {
            log('Permission required for providers.list() - this is expected without user grant');
          } else {
            throw err;
          }
        }
      });
      
      // ---- Tools API ----
      await test('Tools API', 'can list tools (may need permission)', async () => {
        try {
          const tools = await window.agent.tools.list();
          assert(Array.isArray(tools), 'tools.list() should return an array');
          log(`Found ${tools.length} tools`);
        } catch (err) {
          // Permission denied is expected if not granted in test environment
          if (err.message && (err.message.includes('ermission') || err.message.includes('denied'))) {
            log('Permission required for tools.list() - this is expected without user grant');
          } else {
            throw err;
          }
        }
      });
      
      // ---- Session API ----
      await test('Session API', 'can create text session (may need permission)', async () => {
        try {
          const session = await window.ai.createTextSession();
          assert(session !== null, 'createTextSession should return a session');
          assert(typeof session.prompt === 'function', 'session should have prompt method');
          assert(typeof session.destroy === 'function', 'session should have destroy method');
          await session.destroy();
          log('Text session created and destroyed successfully');
        } catch (err) {
          // Permission denied or no LLM configured is expected in test environment
          if (err.message && (
            err.message.includes('ermission') || 
            err.message.includes('denied') ||
            err.message.includes('No model') || 
            err.message.includes('provider')
          )) {
            log('Permission required or no LLM configured - this is expected in test environment');
          } else {
            throw err;
          }
        }
      });
      
      // ---- Page Tools (navigator.modelContext) ----
      await test('Page Tools', 'navigator.modelContext exists', async () => {
        assert(typeof navigator.modelContext === 'object', 'navigator.modelContext should be defined');
        assert(typeof navigator.modelContext.addTool === 'function', 'addTool should be a function');
        assert(typeof navigator.modelContext.removeTool === 'function', 'removeTool should be a function');
        assert(Array.isArray(navigator.modelContext.tools), 'tools should be an array');
      });

      await test('Page Tools', 'addTool registers a page tool', async () => {
        navigator.modelContext.addTool({
          name: 'test_register',
          description: 'A test tool for registration',
          handler: () => ({ registered: true }),
        });
        const found = navigator.modelContext.tools.find(t => t.name === 'test_register');
        assert(found, 'Tool should appear in navigator.modelContext.tools');
        assert(found.description === 'A test tool for registration', 'Description should match');
        navigator.modelContext.removeTool('test_register');
      });

      await test('Page Tools', 'removeTool unregisters a page tool', async () => {
        navigator.modelContext.addTool({
          name: 'test_remove',
          description: 'Will be removed',
          handler: () => null,
        });
        const removed = navigator.modelContext.removeTool('test_remove');
        assert(removed === true, 'removeTool should return true');
        const found = navigator.modelContext.tools.find(t => t.name === 'test_remove');
        assert(!found, 'Tool should not appear after removal');
        // Removing again should return false
        const removedAgain = navigator.modelContext.removeTool('test_remove');
        assert(removedAgain === false, 'removeTool on missing tool should return false');
      });

      await test('Page Tools', 'page tool appears in agent.tools.list()', async () => {
        navigator.modelContext.addTool({
          name: 'list_integration_test',
          description: 'Tests list integration',
          handler: () => 'hello',
        });
        try {
          const tools = await window.agent.tools.list();
          assert(Array.isArray(tools), 'tools.list() should return an array');
          const found = tools.find(t => t.name === 'page/list_integration_test');
          assert(found, 'page/list_integration_test should appear in tools list');
          assert(found.serverId === 'page', 'serverId should be "page"');
          assert(found.description === 'Tests list integration', 'description should match');
        } catch (err) {
          if (err.message && err.message.includes('ermission')) {
            log('Permission required for tools.list() - page tool registered but cannot verify via list');
          } else {
            throw err;
          }
        } finally {
          navigator.modelContext.removeTool('list_integration_test');
        }
      });

      await test('Page Tools', 'agent.tools.call() executes page tool handler', async () => {
        navigator.modelContext.addTool({
          name: 'call_test',
          description: 'Returns a known value',
          handler: (args) => ({ answer: 42, received: args }),
        });
        try {
          const result = await window.agent.tools.call({
            tool: 'page/call_test',
            args: { input: 'test' },
          });
          assert(result && result.answer === 42, 'Handler should return { answer: 42 }');
          assert(result.received && result.received.input === 'test', 'Args should be passed through');
        } finally {
          navigator.modelContext.removeTool('call_test');
        }
      });

      await test('Page Tools', 'agent.tools.call() page tool error produces ERR_TOOL_FAILED', async () => {
        navigator.modelContext.addTool({
          name: 'error_test',
          description: 'Always throws',
          handler: () => { throw new Error('Intentional test error'); },
        });
        try {
          await window.agent.tools.call({ tool: 'page/error_test', args: {} });
          assert(false, 'Should have thrown');
        } catch (err) {
          assert(err.code === 'ERR_TOOL_FAILED', 'Error code should be ERR_TOOL_FAILED, got: ' + err.code);
          assert(err.message.includes('Intentional test error'), 'Error message should contain original message');
        } finally {
          navigator.modelContext.removeTool('error_test');
        }
      });

      await test('Page Tools', 'agent.tools.call() supports bare name for page tools', async () => {
        navigator.modelContext.addTool({
          name: 'bare_name_test',
          description: 'Test bare name resolution',
          handler: () => ({ bare: true }),
        });
        try {
          const result = await window.agent.tools.call({
            tool: 'bare_name_test',
            args: {},
          });
          assert(result && result.bare === true, 'Bare name should resolve to page tool');
        } finally {
          navigator.modelContext.removeTool('bare_name_test');
        }
      });

      await test('Page Tools', 'MCP tools still returned alongside page tools', async () => {
        navigator.modelContext.addTool({
          name: 'coexistence_test',
          description: 'Test MCP coexistence',
          handler: () => null,
        });
        try {
          const tools = await window.agent.tools.list();
          assert(Array.isArray(tools), 'tools.list() should return an array');
          const pageToolFound = tools.find(t => t.name === 'page/coexistence_test');
          assert(pageToolFound, 'Page tool should be in the list');
          // Verify there are no duplicate page entries
          const pageEntries = tools.filter(t => t.serverId === 'page' && t.name === 'page/coexistence_test');
          assert(pageEntries.length === 1, 'Should have exactly one entry for the page tool');
          log(`Total tools: ${tools.length} (MCP: ${tools.filter(t => t.serverId !== 'page').length}, Page: ${tools.filter(t => t.serverId === 'page').length})`);
        } catch (err) {
          if (err.message && err.message.includes('ermission')) {
            log('Permission required for tools.list() - skipping coexistence check');
          } else {
            throw err;
          }
        } finally {
          navigator.modelContext.removeTool('coexistence_test');
        }
      });

      // Finish
      updateProgress('Tests complete!');
      await renderSummary();
    }
    
    // Run tests after a short delay to ensure page is fully loaded
    setTimeout(runTests, 500);
  </script>
</body>
</html>
