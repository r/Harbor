#!/bin/bash
# Harbor Installer - Post-install setup
# This script runs after files are copied to set up native messaging and Firefox extension

set -e

LOG_FILE="/tmp/harbor-install.log"
echo "Harbor post-install started at $(date)" >> "$LOG_FILE"

# Installation paths
HARBOR_DIR="/Library/Application Support/Harbor"
HARBOR_BIN="$HARBOR_DIR/harbor-bridge"
HARBOR_XPI="$HARBOR_DIR/harbor.xpi"
WEB_AGENTS_XPI="$HARBOR_DIR/web-agents.xpi"

# =============================================================================
# Select correct binary for current architecture
# =============================================================================
select_binary() {
    echo "Selecting binary for current architecture..."
    
    # Use sysctl to detect native architecture (works even under Rosetta)
    # uname -m can return x86_64 when running under Rosetta on Apple Silicon
    if sysctl -n hw.optional.arm64 2>/dev/null | grep -q "1"; then
        ARCH="arm64"
    else
        ARCH=$(uname -m)
    fi
    echo "  Detected architecture: $ARCH" >> "$LOG_FILE"
    
    if [ "$ARCH" = "arm64" ]; then
        BINARY_SOURCE="$HARBOR_DIR/harbor-bridge-arm64"
    else
        BINARY_SOURCE="$HARBOR_DIR/harbor-bridge-x64"
    fi
    
    if [ -f "$BINARY_SOURCE" ]; then
        # Copy the correct binary
        cp "$BINARY_SOURCE" "$HARBOR_BIN"
        chmod +x "$HARBOR_BIN"
        echo "  ✓ Selected $ARCH binary"
        echo "  Selected binary: $BINARY_SOURCE -> $HARBOR_BIN" >> "$LOG_FILE"
        
        # Clean up both architecture-specific binaries
        rm -f "$HARBOR_DIR/harbor-bridge-arm64" 2>/dev/null || true
        rm -f "$HARBOR_DIR/harbor-bridge-x64" 2>/dev/null || true
    elif [ -f "$HARBOR_BIN" ]; then
        # Single-arch build already has the binary in place
        echo "  ✓ Using pre-built binary"
        echo "  Using pre-built binary at: $HARBOR_BIN" >> "$LOG_FILE"
    else
        echo "  ✗ ERROR: No suitable binary found for $ARCH!" | tee -a "$LOG_FILE"
        exit 1
    fi
}

# Native messaging paths
FIREFOX_NATIVE_HOSTS="/Library/Application Support/Mozilla/NativeMessagingHosts"
CHROME_NATIVE_HOSTS="/Library/Application Support/Google/Chrome/NativeMessagingHosts"
CHROMIUM_NATIVE_HOSTS="/Library/Application Support/Chromium/NativeMessagingHosts"
MANIFEST_NAME="harbor_bridge"

# Extension IDs (stamped by build-pkg.sh from credentials.env)
# Firefox extension IDs (email format, e.g., "harbor@krikorian.co")
EXTENSION_ID="__EXTENSION_ID__"
WEB_AGENTS_EXTENSION_ID="__WEB_AGENTS_EXTENSION_ID__"
# Chrome extension ID (32-char string, e.g., "abcdefghijklmnopqrstuvwxyzabcdef")
CHROME_EXTENSION_ID="__CHROME_EXTENSION_ID__"

# Which browsers to install for (set by installer choices)
# Can be: "firefox", "chrome", or "both" (default)
INSTALL_BROWSERS="${INSTALL_BROWSERS:-both}"

# =============================================================================
# Create launcher script
# =============================================================================
create_launcher() {
    echo "Creating launcher script..."
    
    LAUNCHER_SCRIPT="$HARBOR_DIR/harbor-bridge-launcher"
    
    cat > "$LAUNCHER_SCRIPT" << 'LAUNCHER_EOF'
#!/bin/bash
# Harbor Bridge Launcher
# Wrapper script for native messaging

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Suppress Node.js warnings that could corrupt the native messaging protocol
export NODE_NO_WARNINGS=1

# Tell pkg where to find native modules (better-sqlite3)
# The native .node files are in the native/ subdirectory
export PKG_EXECPATH="$SCRIPT_DIR/harbor-bridge"

# Log file for debugging
LOG_FILE="$HOME/.harbor/bridge.log"
mkdir -p "$(dirname "$LOG_FILE")"

# Execute the bridge, redirecting stderr to log file
exec "$SCRIPT_DIR/harbor-bridge" 2>>"$LOG_FILE"
LAUNCHER_EOF

    chmod +x "$LAUNCHER_SCRIPT"
    echo "Launcher script created at: $LAUNCHER_SCRIPT" >> "$LOG_FILE"
}

# =============================================================================
# Install native messaging manifest for Firefox
# =============================================================================
install_firefox_native_manifest() {
    echo "Installing Firefox native messaging manifest..."
    
    # Create directory if it doesn't exist
    mkdir -p "$FIREFOX_NATIVE_HOSTS"
    
    # Get the launcher path
    LAUNCHER_PATH="$HARBOR_DIR/harbor-bridge-launcher"
    
    # Create the system-wide manifest
    MANIFEST_FILE="$FIREFOX_NATIVE_HOSTS/${MANIFEST_NAME}.json"
    
    # Build allowed_extensions array (include Web Agents if configured)
    if [ -n "$WEB_AGENTS_EXTENSION_ID" ] && [ "$WEB_AGENTS_EXTENSION_ID" != "__WEB_AGENTS_EXTENSION_ID__" ]; then
        ALLOWED_EXTENSIONS="[\"$EXTENSION_ID\", \"$WEB_AGENTS_EXTENSION_ID\"]"
    else
        ALLOWED_EXTENSIONS="[\"$EXTENSION_ID\"]"
    fi
    
    cat > "$MANIFEST_FILE" << EOF
{
  "name": "$MANIFEST_NAME",
  "description": "Harbor Bridge - AI Agent Platform with MCP Tools",
  "path": "$LAUNCHER_PATH",
  "type": "stdio",
  "allowed_extensions": $ALLOWED_EXTENSIONS
}
EOF

    echo "Firefox native manifest installed at: $MANIFEST_FILE" >> "$LOG_FILE"
    echo "  ✓ Firefox system manifest: $MANIFEST_FILE"
    
    # Also update user-level manifest if it exists (it takes precedence)
    ACTUAL_USER="${SUDO_USER:-}"
    if [ -z "$ACTUAL_USER" ]; then
        ACTUAL_USER=$(stat -f '%Su' /dev/console 2>/dev/null || echo "")
    fi
    
    if [ -n "$ACTUAL_USER" ] && [ "$ACTUAL_USER" != "root" ]; then
        USER_HOME=$(eval echo "~$ACTUAL_USER")
        USER_MANIFEST="$USER_HOME/Library/Application Support/Mozilla/NativeMessagingHosts/${MANIFEST_NAME}.json"
        
        if [ -f "$USER_MANIFEST" ]; then
            echo "  Found user-level Firefox manifest, updating..."
            cat > "$USER_MANIFEST" << EOF
{
  "name": "$MANIFEST_NAME",
  "description": "Harbor Bridge - AI Agent Platform with MCP Tools",
  "path": "$LAUNCHER_PATH",
  "type": "stdio",
  "allowed_extensions": $ALLOWED_EXTENSIONS
}
EOF
            chown "$ACTUAL_USER" "$USER_MANIFEST"
            echo "  ✓ Firefox user manifest updated"
        fi
    fi
}

# =============================================================================
# Install native messaging manifest for Chrome/Chromium
# =============================================================================
install_chrome_native_manifest() {
    echo "Installing Chrome native messaging manifest..."
    
    LAUNCHER_PATH="$HARBOR_DIR/harbor-bridge-launcher"
    
    # Chrome extension ID - stamped from credentials.env by build script
    # This is the ID from Chrome Web Store (32 lowercase letters a-p)
    # Leave as placeholder if not yet published to Web Store
    CHROME_EXTENSION_ID="__CHROME_EXTENSION_ID__"
    
    # Skip if no Chrome extension ID configured
    if [ -z "$CHROME_EXTENSION_ID" ] || [ "$CHROME_EXTENSION_ID" = "__CHROME_EXTENSION_ID__" ]; then
        echo "  ⚠ Chrome extension ID not configured (extension not yet in Web Store?)"
        echo "  Native messaging will be configured when CHROME_EXTENSION_ID is set"
        echo "Chrome extension ID not configured, skipping native messaging" >> "$LOG_FILE"
        return 0
    fi
    
    echo "  Chrome extension ID: $CHROME_EXTENSION_ID"
    
    # Install for Google Chrome
    mkdir -p "$CHROME_NATIVE_HOSTS"
    CHROME_MANIFEST="$CHROME_NATIVE_HOSTS/${MANIFEST_NAME}.json"
    
    cat > "$CHROME_MANIFEST" << EOF
{
  "name": "$MANIFEST_NAME",
  "description": "Harbor Bridge - AI Agent Platform with MCP Tools",
  "path": "$LAUNCHER_PATH",
  "type": "stdio",
  "allowed_origins": ["chrome-extension://$CHROME_EXTENSION_ID/"]
}
EOF

    echo "Chrome native manifest installed at: $CHROME_MANIFEST" >> "$LOG_FILE"
    echo "  ✓ Chrome system manifest: $CHROME_MANIFEST"
    
    # Also install for Chromium (same format)
    mkdir -p "$CHROMIUM_NATIVE_HOSTS"
    CHROMIUM_MANIFEST="$CHROMIUM_NATIVE_HOSTS/${MANIFEST_NAME}.json"
    cp "$CHROME_MANIFEST" "$CHROMIUM_MANIFEST"
    echo "  ✓ Chromium system manifest: $CHROMIUM_MANIFEST"
    
    # Update user-level manifests if they exist
    ACTUAL_USER="${SUDO_USER:-}"
    if [ -z "$ACTUAL_USER" ]; then
        ACTUAL_USER=$(stat -f '%Su' /dev/console 2>/dev/null || echo "")
    fi
    
    if [ -n "$ACTUAL_USER" ] && [ "$ACTUAL_USER" != "root" ]; then
        USER_HOME=$(eval echo "~$ACTUAL_USER")
        
        # Chrome user manifest
        USER_CHROME_DIR="$USER_HOME/Library/Application Support/Google/Chrome/NativeMessagingHosts"
        USER_CHROME_MANIFEST="$USER_CHROME_DIR/${MANIFEST_NAME}.json"
        if [ -f "$USER_CHROME_MANIFEST" ]; then
            cp "$CHROME_MANIFEST" "$USER_CHROME_MANIFEST"
            chown "$ACTUAL_USER" "$USER_CHROME_MANIFEST"
            echo "  ✓ Chrome user manifest updated"
        fi
        
        # Chromium user manifest  
        USER_CHROMIUM_DIR="$USER_HOME/Library/Application Support/Chromium/NativeMessagingHosts"
        USER_CHROMIUM_MANIFEST="$USER_CHROMIUM_DIR/${MANIFEST_NAME}.json"
        if [ -f "$USER_CHROMIUM_MANIFEST" ]; then
            cp "$CHROME_MANIFEST" "$USER_CHROMIUM_MANIFEST"
            chown "$ACTUAL_USER" "$USER_CHROMIUM_MANIFEST"
            echo "  ✓ Chromium user manifest updated"
        fi
    fi
}

# =============================================================================
# Install native messaging manifests (wrapper for both browsers)
# =============================================================================
install_native_manifest() {
    echo "Installing native messaging manifests..."
    
    case "$INSTALL_BROWSERS" in
        firefox)
            install_firefox_native_manifest
            ;;
        chrome)
            install_chrome_native_manifest
            ;;
        both|*)
            install_firefox_native_manifest
            install_chrome_native_manifest
            ;;
    esac
}

# =============================================================================
# Install Firefox extensions via policy
# =============================================================================
install_firefox_extension() {
    echo "Setting up Firefox extensions..."
    
    # Method 1: Try enterprise policies (works on some Firefox installs)
    POLICIES_DIR="/Library/Application Support/Mozilla/policies"
    POLICIES_FILE="$POLICIES_DIR/policies.json"
    
    mkdir -p "$POLICIES_DIR"
    
    # URL-encode the paths (spaces -> %20)
    HARBOR_XPI_URL="file://$(echo "$HARBOR_XPI" | sed 's/ /%20/g')"
    WEB_AGENTS_XPI_URL="file://$(echo "$WEB_AGENTS_XPI" | sed 's/ /%20/g')"
    
    # Build policy JSON based on whether Web Agents extension exists
    if [ -f "$WEB_AGENTS_XPI" ] && [ -n "$WEB_AGENTS_EXTENSION_ID" ] && [ "$WEB_AGENTS_EXTENSION_ID" != "__WEB_AGENTS_EXTENSION_ID__" ]; then
        cat > "$POLICIES_FILE" << EOF
{
  "policies": {
    "Extensions": {
      "Install": [
        "$HARBOR_XPI_URL",
        "$WEB_AGENTS_XPI_URL"
      ]
    },
    "ExtensionSettings": {
      "$EXTENSION_ID": {
        "installation_mode": "normal_installed",
        "install_url": "$HARBOR_XPI_URL"
      },
      "$WEB_AGENTS_EXTENSION_ID": {
        "installation_mode": "normal_installed",
        "install_url": "$WEB_AGENTS_XPI_URL"
      }
    }
  }
}
EOF
    else
        cat > "$POLICIES_FILE" << EOF
{
  "policies": {
    "Extensions": {
      "Install": [
        "$HARBOR_XPI_URL"
      ]
    },
    "ExtensionSettings": {
      "$EXTENSION_ID": {
        "installation_mode": "normal_installed",
        "install_url": "$HARBOR_XPI_URL"
      }
    }
  }
}
EOF
    fi
    echo "  ✓ Firefox policy configured (fallback)"
    
    # Method 2: Open the XPI files to trigger Firefox install prompts
    # Run as the actual user so it opens in their Firefox session
    # Try multiple methods to find the actual user
    ACTUAL_USER="${SUDO_USER:-}"
    if [ -z "$ACTUAL_USER" ]; then
        # Try to get the console user (who is logged in at the GUI)
        ACTUAL_USER=$(stat -f '%Su' /dev/console 2>/dev/null || echo "")
    fi
    if [ -z "$ACTUAL_USER" ]; then
        ACTUAL_USER="$USER"
    fi
    
    echo "  Detected user: $ACTUAL_USER" >> "$LOG_FILE"
    echo "  Detected user: $ACTUAL_USER"
    
    if [ -n "$ACTUAL_USER" ] && [ "$ACTUAL_USER" != "root" ]; then
        echo "  Opening extensions in Firefox for user: $ACTUAL_USER"
        echo "  Opening extensions in Firefox for user: $ACTUAL_USER" >> "$LOG_FILE"
        
        # Open the Harbor XPI file with Firefox - this triggers the install prompt
        # Run in background so it doesn't block the installer
        # Use su to run as the actual user (not root)
        su "$ACTUAL_USER" -c "open -a Firefox '$HARBOR_XPI'" 2>> "$LOG_FILE" &
        echo "  ✓ Harbor extension install prompt triggered"
        
        # Wait for user to install first extension, then open Web Agents extension if it exists
        if [ -f "$WEB_AGENTS_XPI" ]; then
            # Show a dialog asking the user to confirm they've installed Harbor
            # This runs as the actual user so it appears in their GUI session
            su "$ACTUAL_USER" -c "osascript -e 'display dialog \"Click OK after you have installed the Harbor extension in Firefox.\" with title \"Harbor Installer\" buttons {\"OK\"} default button \"OK\"'" 2>> "$LOG_FILE"
            
            su "$ACTUAL_USER" -c "open -a Firefox '$WEB_AGENTS_XPI'" 2>> "$LOG_FILE" &
            echo "  ✓ Web Agents extension install prompt triggered"
        fi
        
        echo "Extensions XPIs opened for $ACTUAL_USER" >> "$LOG_FILE"
    else
        echo "  ⚠ Could not determine user (got: '$ACTUAL_USER'), please install extensions manually"
        echo "Could not determine user: SUDO_USER='$SUDO_USER' USER='$USER'" >> "$LOG_FILE"
        echo "  Open: $HARBOR_XPI"
        if [ -f "$WEB_AGENTS_XPI" ]; then
            echo "  Open: $WEB_AGENTS_XPI"
        fi
    fi
}

# =============================================================================
# Install Chrome extension via Web Store
# =============================================================================
install_chrome_extension() {
    echo "Setting up Chrome extension..."
    
    # Chrome Web Store URL - stamped by build script
    # Format: https://chrome.google.com/webstore/detail/harbor/EXTENSION_ID
    CHROME_WEBSTORE_URL="__CHROME_WEBSTORE_URL__"
    
    # Skip if no Web Store URL configured
    if [ -z "$CHROME_WEBSTORE_URL" ] || [ "$CHROME_WEBSTORE_URL" = "__CHROME_WEBSTORE_URL__" ]; then
        echo "  ⚠ Chrome Web Store URL not configured"
        echo "  For development, load the extension manually:"
        echo "    1. Open Chrome → chrome://extensions/"
        echo "    2. Enable 'Developer mode'"
        echo "    3. Click 'Load unpacked' → select: $HARBOR_DIR/chrome-extension"
        return 0
    fi
    
    # Get the actual user
    ACTUAL_USER="${SUDO_USER:-}"
    if [ -z "$ACTUAL_USER" ]; then
        ACTUAL_USER=$(stat -f '%Su' /dev/console 2>/dev/null || echo "")
    fi
    
    echo "  Opening Chrome Web Store..."
    echo "Chrome Web Store URL: $CHROME_WEBSTORE_URL" >> "$LOG_FILE"
    
    if [ -n "$ACTUAL_USER" ] && [ "$ACTUAL_USER" != "root" ]; then
        # Open Chrome Web Store page to trigger installation
        su "$ACTUAL_USER" -c "open -a 'Google Chrome' '$CHROME_WEBSTORE_URL'" 2>> "$LOG_FILE" &
        echo "  ✓ Chrome Web Store opened"
        echo "  Click 'Add to Chrome' to install the extension"
    else
        echo "  ⚠ Could not determine user, please install manually:"
        echo "    $CHROME_WEBSTORE_URL"
    fi
}

# =============================================================================
# Set permissions
# =============================================================================
set_permissions() {
    echo "Setting permissions..."
    
    # Make the bridge executable
    chmod +x "$HARBOR_BIN"
    
    # Make the uninstall script executable
    if [ -f "$HARBOR_DIR/uninstall.sh" ]; then
        chmod +x "$HARBOR_DIR/uninstall.sh"
    fi
    
    echo "Permissions set" >> "$LOG_FILE"
}

# =============================================================================
# Install uninstaller
# =============================================================================
install_uninstaller() {
    echo "Installing uninstaller..."
    
    # Create CLI symlink
    if [ -d "/usr/local/bin" ]; then
        ln -sf "$HARBOR_DIR/uninstall.sh" "/usr/local/bin/harbor-uninstall"
        echo "  ✓ CLI uninstaller: harbor-uninstall"
    fi
    
    # Create uninstaller app from AppleScript
    # The app is built during the pkg creation, we just copy it
    if [ -d "$HARBOR_DIR/Uninstall Harbor.app" ]; then
        cp -R "$HARBOR_DIR/Uninstall Harbor.app" "/Applications/"
        echo "  ✓ Uninstaller app: /Applications/Uninstall Harbor.app"
    fi
    
    echo "Uninstaller installed" >> "$LOG_FILE"
}

# =============================================================================
# Install Ollama (for Local LLM support)
# =============================================================================
install_ollama() {
    echo "Setting up Ollama for Local LLM..."
    
    # Check if Ollama is already installed
    if command -v ollama &> /dev/null; then
        OLLAMA_VERSION=$(ollama --version 2>/dev/null | head -1 || echo "installed")
        echo "  ✓ Ollama already installed: $OLLAMA_VERSION"
        echo "Ollama already installed: $OLLAMA_VERSION" >> "$LOG_FILE"
        return 0
    fi
    
    # Check if we can install (need network)
    if ! ping -c 1 ollama.com &> /dev/null; then
        echo "  ⚠ Cannot reach ollama.com - skipping Ollama installation"
        echo "    Install Ollama later with: brew install ollama"
        echo "    Or download from: https://ollama.com"
        echo "Cannot reach ollama.com, skipping Ollama install" >> "$LOG_FILE"
        return 0
    fi
    
    # Get the actual user
    ACTUAL_USER="${SUDO_USER:-}"
    if [ -z "$ACTUAL_USER" ]; then
        ACTUAL_USER=$(stat -f '%Su' /dev/console 2>/dev/null || echo "")
    fi
    
    echo "  Downloading Ollama..."
    echo "Downloading Ollama for user: $ACTUAL_USER" >> "$LOG_FILE"
    
    # Create temp directory
    OLLAMA_TEMP="/tmp/harbor-ollama-install"
    mkdir -p "$OLLAMA_TEMP"
    
    # Download Ollama installer
    # Ollama provides a simple install script at https://ollama.com/install.sh
    # Or we can download the macOS app directly
    OLLAMA_URL="https://ollama.com/download/Ollama-darwin.zip"
    OLLAMA_ZIP="$OLLAMA_TEMP/Ollama.zip"
    
    if curl -sL "$OLLAMA_URL" -o "$OLLAMA_ZIP" 2>> "$LOG_FILE"; then
        echo "  Extracting Ollama..."
        
        # Extract to Applications
        cd "$OLLAMA_TEMP"
        unzip -q "$OLLAMA_ZIP" -d "$OLLAMA_TEMP" 2>> "$LOG_FILE"
        
        # Move to Applications
        if [ -d "$OLLAMA_TEMP/Ollama.app" ]; then
            # Remove old version if exists
            rm -rf "/Applications/Ollama.app" 2>/dev/null || true
            
            # Move new version
            mv "$OLLAMA_TEMP/Ollama.app" "/Applications/"
            
            echo "  ✓ Ollama installed to /Applications/Ollama.app"
            echo "Ollama installed to /Applications" >> "$LOG_FILE"
            
            # Launch Ollama (as the user) to set up CLI tools
            if [ -n "$ACTUAL_USER" ] && [ "$ACTUAL_USER" != "root" ]; then
                echo "  Starting Ollama..."
                su "$ACTUAL_USER" -c "open -a Ollama" 2>> "$LOG_FILE" &
                echo "  ✓ Ollama started (it will install CLI tools on first run)"
            fi
        else
            echo "  ⚠ Ollama extraction failed - install manually"
            echo "Ollama extraction failed" >> "$LOG_FILE"
        fi
        
        # Cleanup
        rm -rf "$OLLAMA_TEMP"
    else
        echo "  ⚠ Ollama download failed - install manually"
        echo "    Run: brew install ollama"
        echo "    Or download from: https://ollama.com"
        echo "Ollama download failed" >> "$LOG_FILE"
        
        # Cleanup
        rm -rf "$OLLAMA_TEMP"
    fi
}

# =============================================================================
# Create first-run marker (as the actual user, not root)
# =============================================================================
create_first_run_marker() {
    # Create a marker file so the extension knows this is a fresh install
    # The extension will check for this and show the welcome page
    
    # Get the actual user (the one who ran sudo)
    ACTUAL_USER="${SUDO_USER:-}"
    if [ -z "$ACTUAL_USER" ]; then
        ACTUAL_USER=$(stat -f '%Su' /dev/console 2>/dev/null || echo "")
    fi
    
    if [ -z "$ACTUAL_USER" ] || [ "$ACTUAL_USER" = "root" ]; then
        echo "Could not determine actual user for marker, skipping" >> "$LOG_FILE"
        return 0
    fi
    
    USER_HOME=$(eval echo "~$ACTUAL_USER")
    MARKER_DIR="$USER_HOME/.harbor"
    
    # Create directory as the actual user
    su "$ACTUAL_USER" -c "mkdir -p '$MARKER_DIR'"
    
    # Only create if it doesn't exist (don't overwrite on upgrades)
    if [ ! -f "$MARKER_DIR/.installed" ]; then
        su "$ACTUAL_USER" -c "cat > '$MARKER_DIR/.installed'" << EOF
first_install=$(date +%s)
show_welcome=true
EOF
        echo "First-run marker created for $ACTUAL_USER" >> "$LOG_FILE"
    else
        echo "Upgrade marker exists for $ACTUAL_USER" >> "$LOG_FILE"
    fi
}

# =============================================================================
# Main installation
# =============================================================================

echo ""
echo "═══════════════════════════════════════════════════════════════"
echo "  Harbor - Post-Installation Setup"
echo "═══════════════════════════════════════════════════════════════"
echo ""

# Run installation steps
select_binary
set_permissions
create_launcher
install_native_manifest
install_ollama
install_firefox_extension
install_chrome_extension
install_uninstaller
create_first_run_marker

CHROME_WEBSTORE_URL="__CHROME_WEBSTORE_URL__"

echo ""
echo "═══════════════════════════════════════════════════════════════"
echo ""
echo "✓ Harbor has been installed successfully!"
echo ""
echo "FIREFOX:"
echo "  Firefox will open with extension install prompts."
echo "  Click 'Add' for each extension:"
echo "    • Harbor - Core AI agent platform"
if [ -f "$WEB_AGENTS_XPI" ]; then
echo "    • Web Agents API - Exposes AI to web pages"
fi
echo ""
echo "  Then look for ⚓ in the sidebar."
echo ""
echo "  If Firefox doesn't open, manually open these files:"
echo "    $HARBOR_XPI"
if [ -f "$WEB_AGENTS_XPI" ]; then
echo "    $WEB_AGENTS_XPI"
fi
echo ""
if [ -n "$CHROME_WEBSTORE_URL" ] && [ "$CHROME_WEBSTORE_URL" != "__CHROME_WEBSTORE_URL__" ]; then
echo "CHROME:"
echo "  Chrome Web Store will open. Click 'Add to Chrome' to install."
echo "  Then click the Harbor icon to open the side panel."
echo ""
else
echo "CHROME (Developer Mode):"
echo "  1. Open Chrome → chrome://extensions/"
echo "  2. Enable 'Developer mode' (top right toggle)"
echo "  3. Click 'Load unpacked'"
echo "  4. Select: $HARBOR_DIR/chrome-extension"
echo "  5. Click the Harbor icon to open the side panel"
echo ""
fi
echo "LOCAL LLM:"
echo "  Ollama provides fast, local AI using your Mac's GPU."
echo "  If Ollama wasn't installed, run: brew install ollama"
echo ""
echo "MCP SERVERS:"
echo "  Some MCP servers may require Docker Desktop."
echo ""
echo "To uninstall Harbor later:"
echo "  • Double-click 'Uninstall Harbor' in /Applications"
echo "  • Or run: harbor-uninstall"
echo ""
echo "═══════════════════════════════════════════════════════════════"

echo "Post-install completed successfully at $(date)" >> "$LOG_FILE"
exit 0
