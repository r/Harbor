{
  "version": 3,
  "sources": ["../src/types.ts", "../src/harbor-client.ts", "../src/policy/feature-flags.ts", "../src/background.ts"],
  "sourcesContent": ["/**\n * Web Agents API Types\n * \n * Type definitions for the Web Agents API.\n */\n\n// =============================================================================\n// Permission Types\n// =============================================================================\n\nexport type PermissionScope =\n  | 'model:prompt'              // Text generation\n  | 'model:list'                // List providers/models\n  | 'mcp:tools.list'            // List available tools\n  | 'mcp:tools.call'            // Execute tools\n  | 'browser:activeTab.read'    // Read page content\n  | 'browser:activeTab.interact'// Click, fill, scroll\n  | 'browser:activeTab.screenshot'; // Take screenshots\n\nexport type PermissionGrantType =\n  | 'granted-once'     // Valid for 10 minutes, tab-scoped\n  | 'granted-always'   // Persistent until revoked\n  | 'denied'           // User denied\n  | 'not-granted';     // Never requested\n\nexport interface PermissionGrant {\n  scope: PermissionScope;\n  type: PermissionGrantType;\n  expiresAt?: number;    // For granted-once\n  grantedAt: number;\n}\n\nexport interface PermissionStatus {\n  scope: PermissionScope;\n  status: PermissionGrantType;\n}\n\nexport interface RequestPermissionsOptions {\n  scopes: PermissionScope[];\n  reason?: string;\n  toolAllowlist?: string[];  // For mcp:tools.call\n}\n\nexport interface PermissionResult {\n  granted: PermissionScope[];\n  denied: PermissionScope[];\n}\n\n// =============================================================================\n// LLM Types\n// =============================================================================\n\nexport interface TextSessionOptions {\n  systemPrompt?: string;\n  model?: string;\n  temperature?: number;\n  maxTokens?: number;\n}\n\nexport interface TextSession {\n  sessionId: string;\n  prompt(text: string): Promise<string>;\n  promptStreaming(text: string): AsyncIterable<string>;\n  destroy(): void;\n}\n\nexport type Availability = 'readily' | 'after-download' | 'no';\n\nexport interface Capabilities {\n  available: Availability;\n  defaultTemperature?: number;\n  maxTemperature?: number;\n  defaultTopK?: number;\n  maxTopK?: number;\n}\n\nexport interface Provider {\n  id: string;\n  name: string;\n  type: string;\n  enabled: boolean;\n  models?: string[];\n}\n\n// =============================================================================\n// Tool Types\n// =============================================================================\n\nexport interface ToolDescriptor {\n  serverId: string;\n  name: string;\n  description?: string;\n  inputSchema?: unknown;\n}\n\nexport interface ToolCallOptions {\n  tool: string;       // Format: \"serverId/toolName\" or just \"toolName\"\n  args?: Record<string, unknown>;\n}\n\nexport interface ToolResult {\n  ok: boolean;\n  result?: unknown;\n  error?: string;\n}\n\n// =============================================================================\n// Agent Session Types\n// =============================================================================\n\n/**\n * Session type - how was this session created?\n */\nexport type SessionType = 'implicit' | 'explicit';\n\n/**\n * Session status.\n */\nexport type SessionStatus = 'active' | 'suspended' | 'terminated';\n\n/**\n * Capabilities for LLM access in a session.\n */\nexport interface LLMCapabilities {\n  allowed: boolean;\n  provider?: string;\n  model?: string;\n}\n\n/**\n * Capabilities for tool access in a session.\n */\nexport interface ToolCapabilities {\n  allowed: boolean;\n  allowedTools: string[];\n}\n\n/**\n * Capabilities for browser API access in a session.\n */\nexport interface BrowserCapabilities {\n  readActiveTab: boolean;\n  interact: boolean;\n  screenshot: boolean;\n}\n\n/**\n * Session limits and budgets.\n */\nexport interface SessionLimits {\n  maxToolCalls?: number;\n  expiresAt?: number;\n}\n\n/**\n * Full capability set for a session.\n */\nexport interface SessionCapabilities {\n  llm: LLMCapabilities;\n  tools: ToolCapabilities;\n  browser: BrowserCapabilities;\n  limits?: SessionLimits;\n}\n\n/**\n * Session usage statistics.\n */\nexport interface SessionUsage {\n  promptCount: number;\n  toolCallCount: number;\n  tokensUsed?: number;\n}\n\n/**\n * Summary of a session for listing/display.\n */\nexport interface SessionSummary {\n  sessionId: string;\n  type: SessionType;\n  origin: string;\n  status: SessionStatus;\n  name?: string;\n  createdAt: number;\n  lastActiveAt: number;\n  capabilities: {\n    hasLLM: boolean;\n    toolCount: number;\n    hasBrowserAccess: boolean;\n  };\n  usage: SessionUsage;\n}\n\n/**\n * Options for creating an explicit session.\n */\nexport interface CreateSessionOptions {\n  /** Human-readable name for display */\n  name?: string;\n  /** Reason for requesting these capabilities */\n  reason?: string;\n  /** Requested capabilities */\n  capabilities: {\n    llm?: {\n      provider?: string;\n      model?: string;\n    };\n    tools?: string[];\n    browser?: ('read' | 'interact' | 'screenshot')[];\n  };\n  /** Session limits */\n  limits?: {\n    maxToolCalls?: number;\n    ttlMinutes?: number;\n  };\n  /** Session options */\n  options?: {\n    systemPrompt?: string;\n    temperature?: number;\n  };\n}\n\n/**\n * Result of creating a session.\n */\nexport interface CreateSessionResult {\n  success: boolean;\n  sessionId?: string;\n  capabilities?: SessionCapabilities;\n  error?: {\n    code: 'PERMISSION_DENIED' | 'ORIGIN_DENIED' | 'INVALID_REQUEST';\n    message: string;\n  };\n}\n\n/**\n * Agent session object returned to web pages.\n * This is the programmatic interface for interacting with a session.\n */\nexport interface AgentSessionHandle {\n  readonly sessionId: string;\n  readonly capabilities: SessionCapabilities;\n  \n  /** LLM operations (if llm.allowed) */\n  prompt(input: string): Promise<string>;\n  promptStreaming(input: string): AsyncIterable<string>;\n  \n  /** Tool operations (if tools.allowed) */\n  callTool(tool: string, args?: Record<string, unknown>): Promise<unknown>;\n  listAllowedTools(): string[];\n  \n  /** Session management */\n  terminate(): Promise<void>;\n}\n\n// =============================================================================\n// Message Types (internal)\n// =============================================================================\n\nexport type MessageType =\n  // Permission operations\n  | 'request_permissions'\n  | 'list_permissions'\n  // AI operations\n  | 'create_session'\n  | 'session_prompt'\n  | 'session_prompt_streaming'\n  | 'session_destroy'\n  | 'can_create_session'\n  | 'get_capabilities'\n  | 'list_providers'\n  | 'get_active_provider'\n  // Tool operations\n  | 'list_tools'\n  | 'call_tool'\n  // Session operations\n  | 'session_create_explicit'\n  | 'session_get'\n  | 'session_list'\n  | 'session_terminate';\n\nexport interface TransportRequest {\n  id: string;\n  type: MessageType;\n  payload: unknown;\n}\n\nexport interface TransportResponse {\n  id: string;\n  ok: boolean;\n  result?: unknown;\n  error?: ApiError;\n}\n\nexport interface TransportStreamEvent {\n  id: string;\n  event: StreamToken;\n  done?: boolean;\n}\n\nexport interface StreamToken {\n  type: 'token' | 'done' | 'error';\n  token?: string;\n  error?: ApiError;\n}\n\nexport interface ApiError {\n  code: string;\n  message: string;\n}\n\n// Error codes\nexport const ErrorCodes = {\n  NOT_INSTALLED: 'ERR_NOT_INSTALLED',\n  PERMISSION_DENIED: 'ERR_PERMISSION_DENIED',\n  SCOPE_REQUIRED: 'ERR_SCOPE_REQUIRED',\n  TOOL_NOT_ALLOWED: 'ERR_TOOL_NOT_ALLOWED',\n  TOOL_FAILED: 'ERR_TOOL_FAILED',\n  MODEL_FAILED: 'ERR_MODEL_FAILED',\n  SESSION_NOT_FOUND: 'ERR_SESSION_NOT_FOUND',\n  HARBOR_NOT_FOUND: 'ERR_HARBOR_NOT_FOUND',\n  TIMEOUT: 'ERR_TIMEOUT',\n  INTERNAL: 'ERR_INTERNAL',\n  AGENT_NOT_FOUND: 'ERR_AGENT_NOT_FOUND',\n  AGENT_NOT_ACCEPTING: 'ERR_AGENT_NOT_ACCEPTING',\n} as const;\n\n// =============================================================================\n// Multi-Agent Types\n// =============================================================================\n\n/**\n * Unique identifier for an agent.\n */\nexport type AgentId = string;\n\n/**\n * Agent status.\n */\nexport type AgentStatus = 'active' | 'suspended' | 'terminated';\n\n/**\n * Agent type - where the agent runs.\n */\nexport type AgentType = 'page' | 'worker' | 'remote';\n\n/**\n * Options for registering an agent.\n */\nexport interface AgentRegisterOptions {\n  /** Human-readable name for the agent */\n  name: string;\n  /** Description of what the agent does */\n  description?: string;\n  /** List of capabilities the agent provides */\n  capabilities?: string[];\n  /** Tags for discovery */\n  tags?: string[];\n  /** Whether the agent accepts invocations */\n  acceptsInvocations?: boolean;\n  /** Whether the agent accepts direct messages */\n  acceptsMessages?: boolean;\n}\n\n/**\n * Registered agent information.\n */\nexport interface RegisteredAgent {\n  id: AgentId;\n  name: string;\n  description?: string;\n  capabilities: string[];\n  tags: string[];\n  status: AgentStatus;\n  type: AgentType;\n  origin: string;\n  tabId?: number;\n  acceptsInvocations: boolean;\n  acceptsMessages: boolean;\n  registeredAt: number;\n  lastActiveAt: number;\n}\n\n/**\n * Summary of an agent for discovery (less detailed).\n */\nexport interface AgentSummary {\n  id: AgentId;\n  name: string;\n  description?: string;\n  capabilities: string[];\n  tags: string[];\n  status: AgentStatus;\n  sameOrigin: boolean;\n  isRemote: boolean;\n}\n\n/**\n * Query options for discovering agents.\n */\nexport interface AgentDiscoveryQuery {\n  /** Filter by name (substring match) */\n  name?: string;\n  /** Filter by capabilities (must have all) */\n  capabilities?: string[];\n  /** Filter by tags (must have any) */\n  tags?: string[];\n  /** Include same-origin agents (default: true) */\n  includeSameOrigin?: boolean;\n  /** Include cross-origin agents (default: false, requires permission) */\n  includeCrossOrigin?: boolean;\n}\n\n/**\n * Result of agent discovery.\n */\nexport interface AgentDiscoveryResult {\n  agents: AgentSummary[];\n  total: number;\n}\n\n/**\n * Request to invoke an agent.\n */\nexport interface AgentInvocationRequest {\n  /** The task or action to perform */\n  task: string;\n  /** Input data for the task */\n  input?: unknown;\n  /** Timeout in milliseconds (default: 30000) */\n  timeout?: number;\n}\n\n/**\n * Response from invoking an agent.\n */\nexport interface AgentInvocationResponse {\n  success: boolean;\n  result?: unknown;\n  error?: {\n    code: string;\n    message: string;\n  };\n  executionTime?: number;\n}\n\n/**\n * Message sent between agents.\n */\nexport interface AgentMessage {\n  id: string;\n  from: AgentId;\n  to: AgentId;\n  type: 'request' | 'response' | 'event' | 'error';\n  payload: unknown;\n  correlationId?: string;\n  timestamp: number;\n}\n\n/**\n * Event broadcast by an agent.\n */\nexport interface AgentEvent {\n  type: string;\n  data: unknown;\n  source: AgentId;\n  timestamp: number;\n}\n\n/**\n * Pipeline step configuration.\n */\nexport interface PipelineStep {\n  agentId: AgentId;\n  task: string;\n  inputTransform?: string;\n  outputTransform?: string;\n}\n\n/**\n * Pipeline configuration.\n */\nexport interface PipelineConfig {\n  steps: PipelineStep[];\n}\n\n/**\n * Parallel task configuration.\n */\nexport interface ParallelTask {\n  agentId: AgentId;\n  task: string;\n  input?: unknown;\n}\n\n/**\n * Parallel execution configuration.\n */\nexport interface ParallelConfig {\n  tasks: ParallelTask[];\n  combineStrategy?: 'array' | 'merge' | 'first';\n}\n\n/**\n * Route configuration for routing.\n */\nexport interface RouteConfig {\n  condition: string;\n  agentId: AgentId;\n}\n\n/**\n * Router configuration.\n */\nexport interface RouterConfig {\n  routes: RouteConfig[];\n  defaultAgentId?: AgentId;\n}\n", "/**\n * Harbor Client\n * \n * Client for communicating with the Harbor extension.\n * Uses chrome.runtime.sendMessage to call Harbor's extension API.\n * \n * Safari: Uses HTTP to communicate with harbor-bridge directly,\n * since Safari doesn't support cross-extension messaging.\n */\n\nimport { ErrorCodes, type ApiError } from './types';\n\n// =============================================================================\n// Configuration\n// =============================================================================\n\n// Known Harbor extension IDs (production and development)\nconst KNOWN_HARBOR_IDS = [\n  'harbor@krikorian.co',  // Firefox AMO signed ID (current)\n  'harbor@mozilla.org',  // Firefox production ID (future)\n  'raffi.krikorian.harbor@gmail.com',  // Firefox AMO signed ID (old)\n  // Chrome stable dev ID (generated from key in manifest.chrome.json)\n  // All developers loading from the repo will get this same ID\n  'ljnciidcajlichemnbohopnlaonhkpgm',\n  // Safari extension bundle identifier\n  'org.harbor.Extension',\n  // Add Chrome Web Store ID here when published (will be different)\n];\n\n// Timeout for requests (ms)\nconst REQUEST_TIMEOUT = 30000;\n\n// Safari HTTP bridge URL\nconst SAFARI_HTTP_BASE = 'http://127.0.0.1:8766';\n\n// =============================================================================\n// State\n// =============================================================================\n\nlet harborExtensionId: string | null = null;\nlet connectionState: 'unknown' | 'connected' | 'not-found' = 'unknown';\n\n// =============================================================================\n// Types\n// =============================================================================\n\ninterface HarborRequest {\n  type: string;\n  payload?: unknown;\n  requestId?: string;\n}\n\ninterface HarborResponse {\n  ok: boolean;\n  result?: unknown;\n  error?: string;\n}\n\nexport interface StreamEvent {\n  type: 'token' | 'done' | 'error';\n  token?: string;\n  finish_reason?: string;\n  model?: string;\n  error?: { code: number; message: string };\n}\n\n// =============================================================================\n// Discovery\n// =============================================================================\n\n/**\n * Discover the Harbor extension by trying known extension IDs.\n * Returns the extension ID if found, null otherwise.\n * \n * Safari: Uses HTTP to communicate with harbor-bridge directly.\n */\nexport async function discoverHarbor(): Promise<string | null> {\n  console.log('[Web Agents API] Starting Harbor discovery...');\n  \n  // If already discovered, return cached ID\n  if (harborExtensionId && connectionState === 'connected') {\n    console.log('[Web Agents API] Using cached Harbor ID:', harborExtensionId);\n    return harborExtensionId;\n  }\n\n  // Safari: Try HTTP connection to harbor-bridge\n  if (isSafari()) {\n    console.log('[Web Agents API] Safari detected, trying HTTP connection to bridge...');\n    try {\n      const response = await fetch(`${SAFARI_HTTP_BASE}/health`, { method: 'GET' });\n      if (response.ok) {\n        // Bridge is available - consider Harbor \"connected\" via bridge\n        harborExtensionId = 'safari-bridge';\n        connectionState = 'connected';\n        console.log('[Web Agents API] Safari: Harbor bridge available via HTTP');\n        return harborExtensionId;\n      }\n    } catch (e) {\n      console.log('[Web Agents API] Safari HTTP connection failed:', e);\n    }\n    console.log('[Web Agents API] Safari: Harbor bridge not found');\n    connectionState = 'not-found';\n    return null;\n  }\n\n  // Chrome/Firefox: Try each known ID\n  for (const id of KNOWN_HARBOR_IDS) {\n    console.log('[Web Agents API] Trying known ID:', id);\n    try {\n      const response = await sendMessageToExtension(id, { type: 'system.getVersion' });\n      console.log('[Web Agents API] Response from', id, ':', response);\n      if (response?.ok) {\n        harborExtensionId = id;\n        connectionState = 'connected';\n        console.log('[Web Agents API] Harbor discovered:', id);\n        return id;\n      }\n    } catch (e) {\n      console.log('[Web Agents API] Failed to contact', id, ':', e);\n      // Extension not found or not responding, try next\n    }\n  }\n\n  // Try to find Harbor by probing (for development/unpacked extensions)\n  // This uses the externally_connectable pattern\n  try {\n    // In Firefox, we can use the extension ID from the discovery script\n    const storageResult = await chrome.storage.local.get('harbor_extension_id');\n    console.log('[Web Agents API] Stored Harbor ID:', storageResult.harbor_extension_id);\n    if (storageResult.harbor_extension_id) {\n      const id = storageResult.harbor_extension_id;\n      try {\n        const response = await sendMessageToExtension(id, { type: 'system.getVersion' });\n        console.log('[Web Agents API] Response from stored ID:', response);\n        if (response?.ok) {\n          harborExtensionId = id;\n          connectionState = 'connected';\n          console.log('[Web Agents API] Harbor discovered via storage:', id);\n          return id;\n        }\n      } catch (e) {\n        console.log('[Web Agents API] Failed to contact stored ID:', e);\n      }\n    }\n  } catch (e) {\n    console.log('[Web Agents API] Storage access failed:', e);\n  }\n\n  console.log('[Web Agents API] Harbor not found');\n  connectionState = 'not-found';\n  return null;\n}\n\n/**\n * Get the current Harbor connection state.\n */\nexport function getHarborState(): { connected: boolean; extensionId: string | null } {\n  return {\n    connected: connectionState === 'connected',\n    extensionId: harborExtensionId,\n  };\n}\n\n/**\n * Set the Harbor extension ID (called when discovered via content script).\n */\nexport function setHarborExtensionId(id: string): void {\n  harborExtensionId = id;\n  connectionState = 'connected';\n  // Persist for future sessions\n  chrome.storage.local.set({ harbor_extension_id: id }).catch(() => {});\n}\n\n// =============================================================================\n// Communication\n// =============================================================================\n\n/**\n * Detect Safari browser.\n */\nfunction isSafari(): boolean {\n  return typeof browser !== 'undefined' && \n         navigator.userAgent.includes('Safari') && \n         !navigator.userAgent.includes('Chrome');\n}\n\n/**\n * Send a message to a specific extension.\n * Uses Promise-based API for Firefox compatibility.\n * Safari requires special handling for cross-extension messaging.\n */\nasync function sendMessageToExtension(\n  extensionId: string,\n  message: HarborRequest,\n): Promise<HarborResponse> {\n  console.log('[Web Agents API] sendMessageToExtension:', extensionId, message.type, 'safari:', isSafari());\n  \n  // Create a timeout promise\n  const timeoutPromise = new Promise<never>((_, reject) => {\n    setTimeout(() => {\n      reject(new Error(`Request timed out after ${REQUEST_TIMEOUT}ms`));\n    }, REQUEST_TIMEOUT);\n  });\n\n  // Create the message promise\n  const messagePromise = new Promise<HarborResponse>((resolve, reject) => {\n    try {\n      // Safari: Use browser API if available\n      if (isSafari() && typeof browser !== 'undefined' && browser.runtime?.sendMessage) {\n        console.log('[Web Agents API] Using Safari/browser API for cross-extension message');\n        browser.runtime.sendMessage(extensionId, message)\n          .then((response: unknown) => {\n            console.log('[Web Agents API] Safari sendMessage response:', response);\n            resolve(response as HarborResponse);\n          })\n          .catch((e: unknown) => {\n            console.log('[Web Agents API] Safari sendMessage error:', e);\n            reject(e);\n          });\n        return;\n      }\n      \n      // In Firefox, chrome.runtime.sendMessage returns a Promise\n      // In Chrome, it uses a callback\n      const result = chrome.runtime.sendMessage(extensionId, message, (response) => {\n        // This callback is used in Chrome\n        if (chrome.runtime.lastError) {\n          console.log('[Web Agents API] sendMessage error:', chrome.runtime.lastError.message);\n          reject(new Error(chrome.runtime.lastError.message));\n          return;\n        }\n        console.log('[Web Agents API] sendMessage response (callback):', response);\n        resolve(response as HarborResponse);\n      });\n      \n      // In Firefox, sendMessage returns a Promise\n      if (result && typeof (result as Promise<unknown>).then === 'function') {\n        (result as Promise<unknown>)\n          .then((response) => {\n            console.log('[Web Agents API] sendMessage response (promise):', response);\n            resolve(response as HarborResponse);\n          })\n          .catch((e) => {\n            console.log('[Web Agents API] sendMessage promise error:', e);\n            reject(e);\n          });\n      }\n    } catch (e) {\n      console.log('[Web Agents API] sendMessage exception:', e);\n      reject(e);\n    }\n  });\n\n  // Race between message and timeout\n  return Promise.race([messagePromise, timeoutPromise]);\n}\n\n/**\n * Safari: Send RPC request via HTTP to harbor-bridge.\n */\nasync function safariHttpRequest<T>(method: string, params: unknown = {}): Promise<T> {\n  const id = `${Date.now()}-${Math.random().toString(36).slice(2)}`;\n  console.log('[Web Agents API:Safari] HTTP RPC:', method);\n  \n  const response = await fetch(`${SAFARI_HTTP_BASE}/rpc`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ id, method, params }),\n  });\n  \n  if (!response.ok) {\n    throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n  }\n  \n  const data = await response.json();\n  if (data?.error) {\n    throw new Error(data.error.message || JSON.stringify(data.error));\n  }\n  \n  return (data?.result ?? null) as T;\n}\n\n/**\n * Send a request to Harbor.\n * Throws if Harbor is not connected.\n * \n * Safari: Routes to harbor-bridge via HTTP.\n */\nexport async function harborRequest<T = unknown>(\n  type: string,\n  payload?: unknown,\n): Promise<T> {\n  if (!harborExtensionId || connectionState !== 'connected') {\n    // Try to discover Harbor first\n    const id = await discoverHarbor();\n    if (!id) {\n      throw createError(ErrorCodes.HARBOR_NOT_FOUND, 'Harbor extension not found. Please install Harbor.');\n    }\n  }\n\n  // Safari: Use HTTP to bridge\n  if (isSafari()) {\n    // Map Web Agents API calls to bridge RPC methods where possible\n    // Note: Some features may not be available in Safari (agent control, etc.)\n    const methodMap: Record<string, string> = {\n      'system.health': 'system.health',\n      'system.getVersion': 'system.health', // No version on bridge, use health\n      'system.getCapabilities': 'system.health', // Simplified\n      'llm.listProviders': 'llm.list_providers',\n      'llm.chat': 'llm.chat',\n      'mcp.listServers': 'js.list_servers',\n      'mcp.listTools': 'mcp.list_tools', // Tools synced from Harbor\n      'mcp.callTool': 'mcp.call_tool', // Tool execution via bridge\n    };\n    \n    const bridgeMethod = methodMap[type];\n    if (bridgeMethod) {\n      // Bridge returns { result: ... }, return just the result to match Chrome/Firefox behavior\n      const result = await safariHttpRequest<T>(bridgeMethod, payload);\n      return result;\n    }\n    \n    // For unmapped methods, return a \"not supported\" response\n    console.log('[Web Agents API:Safari] Method not supported via bridge:', type);\n    return { supported: false } as unknown as T;\n  }\n\n  const response = await sendMessageToExtension(harborExtensionId!, { type, payload });\n\n  if (!response.ok) {\n    throw createError(ErrorCodes.INTERNAL, response.error || 'Unknown error from Harbor');\n  }\n\n  return response.result as T;\n}\n\n/**\n * Create a streaming request to Harbor.\n * Uses a port connection for streaming responses.\n */\nexport function harborStreamRequest(\n  type: string,\n  payload?: unknown,\n): { stream: AsyncIterable<StreamEvent>; cancel: () => void } {\n  if (!harborExtensionId || connectionState !== 'connected') {\n    throw createError(ErrorCodes.HARBOR_NOT_FOUND, 'Harbor extension not found');\n  }\n\n  const requestId = `stream-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n  const eventQueue: StreamEvent[] = [];\n  let resolveWaiting: ((event: StreamEvent | null) => void) | null = null;\n  let done = false;\n  let error: Error | null = null;\n  let port: chrome.runtime.Port | null = null;\n\n  // Create port connection for streaming\n  try {\n    port = chrome.runtime.connect(harborExtensionId!, { name: 'stream' });\n  } catch (e) {\n    throw createError(ErrorCodes.HARBOR_NOT_FOUND, 'Failed to connect to Harbor');\n  }\n\n  port.onMessage.addListener((message: { type: string; requestId: string; event?: StreamEvent }) => {\n    if (message.requestId !== requestId) return;\n\n    if (message.type === 'stream' && message.event) {\n      const event = message.event;\n      \n      if (resolveWaiting) {\n        resolveWaiting(event);\n        resolveWaiting = null;\n      } else {\n        eventQueue.push(event);\n      }\n\n      if (event.type === 'done' || event.type === 'error') {\n        done = true;\n        if (event.type === 'error' && event.error) {\n          error = new Error(event.error.message);\n        }\n      }\n    }\n  });\n\n  port.onDisconnect.addListener(() => {\n    done = true;\n    if (resolveWaiting) {\n      resolveWaiting(null);\n      resolveWaiting = null;\n    }\n  });\n\n  // Send the request\n  port.postMessage({ type, payload, requestId });\n\n  // Create async iterable\n  const stream: AsyncIterable<StreamEvent> = {\n    [Symbol.asyncIterator]() {\n      return {\n        async next(): Promise<IteratorResult<StreamEvent>> {\n          // Check for queued events\n          if (eventQueue.length > 0) {\n            const event = eventQueue.shift()!;\n            if (event.type === 'done' || event.type === 'error') {\n              return { done: true, value: event };\n            }\n            return { done: false, value: event };\n          }\n\n          // Check if done\n          if (done) {\n            if (error) {\n              throw error;\n            }\n            return { done: true, value: undefined as unknown as StreamEvent };\n          }\n\n          // Wait for next event\n          const event = await new Promise<StreamEvent | null>((resolve) => {\n            resolveWaiting = resolve;\n          });\n\n          if (event === null) {\n            if (error) {\n              throw error;\n            }\n            return { done: true, value: undefined as unknown as StreamEvent };\n          }\n\n          if (event.type === 'done' || event.type === 'error') {\n            return { done: true, value: event };\n          }\n\n          return { done: false, value: event };\n        },\n      };\n    },\n  };\n\n  const cancel = () => {\n    done = true;\n    if (port) {\n      port.disconnect();\n      port = null;\n    }\n  };\n\n  return { stream, cancel };\n}\n\n// =============================================================================\n// Health Check\n// =============================================================================\n\n/**\n * Check if Harbor is healthy and responding.\n */\nexport async function checkHarborHealth(): Promise<boolean> {\n  try {\n    const result = await harborRequest<{ healthy: boolean }>('system.health');\n    return result.healthy;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get Harbor capabilities.\n */\nexport async function getHarborCapabilities(): Promise<{\n  bridgeReady: boolean;\n  features: {\n    llm: boolean;\n    mcp: boolean;\n    oauth: boolean;\n    streaming: boolean;\n  };\n}> {\n  return harborRequest('system.getCapabilities');\n}\n\n// =============================================================================\n// Helpers\n// =============================================================================\n\nfunction createError(code: string, message: string): ApiError & Error {\n  const error = new Error(message) as ApiError & Error;\n  error.code = code;\n  return error;\n}\n", "/**\n * Feature Flags for Web Agents API\n * \n * Controls which APIs are exposed to web pages.\n * These flags are managed via the sidebar UI.\n * \n * ## API Categories\n * \n * **Text Generation (textGeneration):**\n * - window.ai - LLM prompts and text sessions\n * \n * **Tool Calling (toolCalling):**\n * - agent.run() - LLM-driven tool calling loops\n * \n * **Tool Access (toolAccess):**\n * - agent.tools.list() / agent.tools.call() - Manual MCP tool access\n * \n * **Browser Interaction (browserInteraction):**\n * - agent.browser.activeTab.click/fill/scroll/select\n * - Same-tab page manipulation\n * \n * **Browser Control (browserControl):**\n * - agent.browser.navigate/tabs/fetch\n * - Multi-tab control and web fetch\n * \n * **Multi-Agent (multiAgent):**\n * - agent.agents.* - Agent-to-agent communication\n */\n\nexport const STORAGE_KEY = 'web-agents-api-flags';\n\nexport interface FeatureFlags {\n  /**\n   * Enable text generation APIs (window.ai).\n   * Default: true\n   */\n  textGeneration: boolean;\n\n  /**\n   * Enable tool calling APIs (agent.run).\n   * LLM-driven tool calling loops.\n   * Default: false\n   */\n  toolCalling: boolean;\n\n  /**\n   * Enable manual MCP tool access (agent.tools.*).\n   * Default: true\n   */\n  toolAccess: boolean;\n\n  /**\n   * Enable browser interaction APIs (click, fill, scroll, select).\n   * Same-tab page manipulation only.\n   * Default: false\n   */\n  browserInteraction: boolean;\n\n  /**\n   * Enable browser control APIs (navigate, tabs, fetch).\n   * Multi-tab and navigation control.\n   * Default: false\n   */\n  browserControl: boolean;\n\n  /**\n   * Enable multi-agent APIs (agent.agents.*).\n   * Agent-to-agent communication and orchestration.\n   * Default: false\n   */\n  multiAgent: boolean;\n}\n\nexport const DEFAULT_FLAGS: FeatureFlags = {\n  textGeneration: true,\n  toolCalling: false,\n  toolAccess: true,\n  browserInteraction: false,\n  browserControl: false,\n  multiAgent: false,\n};\n\nlet cachedFlags: FeatureFlags | null = null;\n\n/**\n * Get current feature flags.\n */\nexport async function getFeatureFlags(): Promise<FeatureFlags> {\n  if (cachedFlags) {\n    return cachedFlags;\n  }\n\n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEY);\n    cachedFlags = { ...DEFAULT_FLAGS, ...result[STORAGE_KEY] };\n    return cachedFlags;\n  } catch {\n    return DEFAULT_FLAGS;\n  }\n}\n\n/**\n * Get feature flags synchronously from cache.\n * Returns defaults if not yet loaded.\n */\nexport function getFeatureFlagsSync(): FeatureFlags {\n  return cachedFlags || DEFAULT_FLAGS;\n}\n\n/**\n * Update feature flags.\n */\nexport async function setFeatureFlags(flags: Partial<FeatureFlags>): Promise<void> {\n  const current = await getFeatureFlags();\n  const updated = { ...current, ...flags };\n  \n  await chrome.storage.local.set({ [STORAGE_KEY]: updated });\n  cachedFlags = updated;\n}\n\n/**\n * Check if a specific feature is enabled.\n */\nexport async function isFeatureEnabled(feature: keyof FeatureFlags): Promise<boolean> {\n  const flags = await getFeatureFlags();\n  return flags[feature];\n}\n\n/**\n * Reset all flags to defaults.\n */\nexport async function resetFeatureFlags(): Promise<void> {\n  await chrome.storage.local.remove(STORAGE_KEY);\n  cachedFlags = null;\n}\n\n/**\n * Initialize flags cache on module load.\n */\nexport async function initFeatureFlags(): Promise<FeatureFlags> {\n  return getFeatureFlags();\n}\n\n// Listen for storage changes to invalidate cache\nif (typeof chrome !== 'undefined' && chrome.storage?.onChanged) {\n  chrome.storage.onChanged.addListener((changes, areaName) => {\n    if (areaName === 'local' && changes[STORAGE_KEY]) {\n      cachedFlags = null;\n    }\n  });\n}\n", "/**\n * Web Agents API - Background Script\n *\n * Routes messages from content scripts to Harbor extension.\n * Handles permissions and session management.\n */\n\nimport {\n  harborRequest,\n  harborStreamRequest,\n  discoverHarbor,\n  setHarborExtensionId,\n  getHarborState,\n  type StreamEvent,\n} from './harbor-client';\nimport { getFeatureFlags, type FeatureFlags } from './policy/feature-flags';\nimport type {\n  TransportResponse,\n  TransportStreamEvent,\n  PermissionScope,\n  PermissionGrantType,\n  StreamToken,\n  CreateSessionOptions,\n  SessionSummary,\n} from './types';\n\nconsole.log('[Web Agents API] Extension starting...');\n\n// =============================================================================\n// Browser Compatibility Layer\n// =============================================================================\n\n// Firefox uses `browser.*` APIs, Chrome uses `chrome.*`\n// This provides a unified interface for script execution\nconst browserAPI = (typeof browser !== 'undefined' ? browser : chrome) as typeof chrome;\n\n/**\n * Execute a script in a tab, compatible with both Chrome and Firefox.\n */\nasync function executeScriptInTab<T>(\n  tabId: number,\n  func: (...args: unknown[]) => T,\n  args: unknown[] = []\n): Promise<T | undefined> {\n  // Try chrome.scripting first (Chrome MV3, Firefox MV3 with scripting)\n  if (chrome?.scripting?.executeScript) {\n    const results = await chrome.scripting.executeScript({\n      target: { tabId },\n      func: func as () => T,\n      args,\n    });\n    return results?.[0]?.result as T | undefined;\n  }\n  \n  // Try browser.scripting (Firefox MV3)\n  if (typeof browser !== 'undefined' && browser?.scripting?.executeScript) {\n    const results = await browser.scripting.executeScript({\n      target: { tabId },\n      func: func as () => T,\n      args,\n    });\n    return results?.[0]?.result as T | undefined;\n  }\n\n  // Fallback: browser.tabs.executeScript (Firefox MV2 style, but still works)\n  if (typeof browser !== 'undefined' && browser?.tabs?.executeScript) {\n    // For this fallback, we need to serialize the function\n    const code = `(${func.toString()}).apply(null, ${JSON.stringify(args)})`;\n    const results = await browser.tabs.executeScript(tabId, { code });\n    return results?.[0] as T | undefined;\n  }\n\n  throw new Error('No script execution API available');\n}\n\n// =============================================================================\n// State Management\n// =============================================================================\n\n// Permission storage key prefix\nconst PERMISSION_KEY_PREFIX = 'permissions:';\n\n// Active text sessions (sessionId -> session info)\nconst textSessions = new Map<string, {\n  sessionId: string;\n  origin: string;\n  options: Record<string, unknown>;\n  history: Array<{ role: string; content: string }>;\n  createdAt: number;\n}>();\n\nlet sessionIdCounter = 0;\n\nfunction generateSessionId(): string {\n  return `session-${Date.now()}-${++sessionIdCounter}`;\n}\n\n// Track tabs spawned by each origin (origin -> Set<tabId>)\nconst spawnedTabs = new Map<string, Set<number>>();\n\nfunction trackSpawnedTab(origin: string, tabId: number): void {\n  if (!spawnedTabs.has(origin)) {\n    spawnedTabs.set(origin, new Set());\n  }\n  spawnedTabs.get(origin)!.add(tabId);\n}\n\nfunction untrackSpawnedTab(origin: string, tabId: number): boolean {\n  const tabs = spawnedTabs.get(origin);\n  if (tabs) {\n    return tabs.delete(tabId);\n  }\n  return false;\n}\n\nfunction isSpawnedTab(origin: string, tabId: number): boolean {\n  return spawnedTabs.get(origin)?.has(tabId) ?? false;\n}\n\n// Clean up spawned tabs when they are closed\nchrome.tabs.onRemoved.addListener((tabId) => {\n  for (const tabs of spawnedTabs.values()) {\n    tabs.delete(tabId);\n  }\n});\n\n// =============================================================================\n// Permission Management\n// =============================================================================\n\ninterface StoredPermissions {\n  scopes: Record<PermissionScope, { type: PermissionGrantType; expiresAt?: number; grantedAt: number }>;\n  allowedTools?: string[];\n}\n\ninterface PermissionStatusEntry {\n  origin: string;\n  scopes: Record<string, PermissionGrantType>;\n  allowedTools?: string[];\n}\n\nasync function getPermissions(origin: string): Promise<StoredPermissions> {\n  const key = PERMISSION_KEY_PREFIX + origin;\n  const result = await chrome.storage.local.get(key);\n  return result[key] || { scopes: {} };\n}\n\nasync function savePermissions(origin: string, permissions: StoredPermissions): Promise<void> {\n  const key = PERMISSION_KEY_PREFIX + origin;\n  await chrome.storage.local.set({ [key]: permissions });\n}\n\nasync function listAllPermissions(): Promise<PermissionStatusEntry[]> {\n  const result = await chrome.storage.local.get(null);\n  const entries: PermissionStatusEntry[] = [];\n\n  for (const [key, value] of Object.entries(result)) {\n    if (!key.startsWith(PERMISSION_KEY_PREFIX)) continue;\n    const origin = key.slice(PERMISSION_KEY_PREFIX.length);\n    const permissions = (value || { scopes: {} }) as StoredPermissions;\n    const scopes: Record<string, PermissionGrantType> = {};\n\n    for (const [scope, grant] of Object.entries(permissions.scopes || {})) {\n      if (grant.type === 'granted-once' && grant.expiresAt && Date.now() > grant.expiresAt) {\n        scopes[scope] = 'not-granted';\n      } else {\n        scopes[scope] = grant.type;\n      }\n    }\n\n    entries.push({\n      origin,\n      scopes,\n      allowedTools: permissions.allowedTools,\n    });\n  }\n\n  return entries;\n}\n\nasync function revokeOriginPermissions(origin: string): Promise<void> {\n  const key = PERMISSION_KEY_PREFIX + origin;\n  await chrome.storage.local.remove(key);\n}\n\nasync function checkPermission(origin: string, scope: PermissionScope): Promise<PermissionGrantType> {\n  const permissions = await getPermissions(origin);\n  const grant = permissions.scopes[scope];\n  \n  if (!grant) {\n    return 'not-granted';\n  }\n  \n  // Check expiration for granted-once\n  if (grant.type === 'granted-once' && grant.expiresAt) {\n    if (Date.now() > grant.expiresAt) {\n      return 'not-granted';\n    }\n  }\n  \n  return grant.type;\n}\n\nasync function hasPermission(origin: string, scope: PermissionScope): Promise<boolean> {\n  const status = await checkPermission(origin, scope);\n  return status === 'granted-once' || status === 'granted-always';\n}\n\n// =============================================================================\n// Permission Prompt\n// =============================================================================\n\ninterface PermissionPromptResponse {\n  promptId: string;\n  granted: boolean;\n  grantType?: 'granted-once' | 'granted-always';\n  allowedTools?: string[];\n  explicitDeny?: boolean;\n}\n\ninterface PendingPrompt {\n  resolve: (response: PermissionPromptResponse) => void;\n  windowId?: number;\n}\n\nconst pendingPermissionPrompts = new Map<string, PendingPrompt>();\nlet promptIdCounter = 0;\n\nfunction generatePromptId(): string {\n  return `prompt-${Date.now()}-${++promptIdCounter}`;\n}\n\nfunction resolvePromptClosed(windowId: number): void {\n  for (const [promptId, pending] of pendingPermissionPrompts.entries()) {\n    if (pending.windowId === windowId) {\n      pendingPermissionPrompts.delete(promptId);\n      pending.resolve({ promptId, granted: false });\n      return;\n    }\n  }\n}\n\nasync function openPermissionPrompt(options: {\n  origin: string;\n  scopes: PermissionScope[];\n  reason?: string;\n  tools?: string[];\n}): Promise<PermissionPromptResponse> {\n  const promptId = generatePromptId();\n\n  const url = new URL(chrome.runtime.getURL('permission-prompt.html'));\n  url.searchParams.set('promptId', promptId);\n  url.searchParams.set('origin', options.origin);\n  if (options.scopes.length > 0) {\n    url.searchParams.set('scopes', options.scopes.join(','));\n  }\n  if (options.reason) {\n    url.searchParams.set('reason', options.reason);\n  }\n  if (options.tools && options.tools.length > 0) {\n    url.searchParams.set('tools', options.tools.join(','));\n  }\n\n  return new Promise((resolve) => {\n    pendingPermissionPrompts.set(promptId, { resolve });\n\n    chrome.windows.create(\n      {\n        url: url.toString(),\n        type: 'popup',\n        width: 480,\n        height: 640,\n      },\n      (createdWindow) => {\n        if (chrome.runtime.lastError || !createdWindow?.id) {\n          pendingPermissionPrompts.delete(promptId);\n          resolve({ promptId, granted: false });\n          return;\n        }\n\n        const pending = pendingPermissionPrompts.get(promptId);\n        if (pending) {\n          pending.windowId = createdWindow.id;\n        }\n      },\n    );\n  });\n}\n\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n  if (message?.type !== 'permission_prompt_response') {\n    return false;\n  }\n\n  const response = message.response as PermissionPromptResponse | undefined;\n  if (!response) {\n    sendResponse({ ok: false });\n    return true;\n  }\n\n  let promptId = response.promptId;\n  if (!promptId && pendingPermissionPrompts.size === 1) {\n    promptId = Array.from(pendingPermissionPrompts.keys())[0];\n  }\n\n  const pending = promptId ? pendingPermissionPrompts.get(promptId) : undefined;\n  if (!pending) {\n    sendResponse({ ok: false });\n    return true;\n  }\n\n  pendingPermissionPrompts.delete(promptId);\n  if (pending.windowId) {\n    chrome.windows.remove(pending.windowId);\n  }\n\n  pending.resolve({ ...response, promptId });\n  sendResponse({ ok: true });\n  return true;\n});\n\nchrome.windows.onRemoved.addListener((windowId) => {\n  resolvePromptClosed(windowId);\n});\n\nfunction handleWebAgentsPermissionsMessage(\n  message: { type?: string; origin?: string },\n  sendResponse: (response?: unknown) => void,\n): boolean {\n  if (message?.type === 'web_agents_permissions.list_all') {\n    (async () => {\n      const permissions = await listAllPermissions();\n      sendResponse({ ok: true, permissions });\n    })().catch((error) => {\n      sendResponse({ ok: false, error: error instanceof Error ? error.message : String(error) });\n    });\n    return true;\n  }\n\n  if (message?.type === 'web_agents_permissions.revoke_origin') {\n    const { origin } = message as { origin?: string };\n    if (!origin) {\n      sendResponse({ ok: false, error: 'Missing origin' });\n      return true;\n    }\n\n    (async () => {\n      await revokeOriginPermissions(origin);\n      sendResponse({ ok: true });\n    })().catch((error) => {\n      sendResponse({ ok: false, error: error instanceof Error ? error.message : String(error) });\n    });\n    return true;\n  }\n\n  return false;\n}\n\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n  return handleWebAgentsPermissionsMessage(message, sendResponse);\n});\n\nchrome.runtime.onMessageExternal?.addListener((message, _sender, sendResponse) => {\n  return handleWebAgentsPermissionsMessage(message, sendResponse);\n});\n\nasync function showPermissionPrompt(\n  origin: string,\n  scopes: PermissionScope[],\n  reason?: string,\n  tools?: string[],\n): Promise<{ granted: boolean; scopes: Record<PermissionScope, PermissionGrantType>; allowedTools?: string[] }> {\n  const permissions = await getPermissions(origin);\n  const result: Record<PermissionScope, PermissionGrantType> = {};\n  const scopesToRequest: PermissionScope[] = [];\n  const requestedTools = tools && tools.length > 0 ? tools : [];\n  const existingAllowedTools = permissions.allowedTools || [];\n  const missingTools = requestedTools.filter((tool) => !existingAllowedTools.includes(tool));\n  \n  for (const scope of scopes) {\n    // Check if already granted\n    const existing = await checkPermission(origin, scope);\n    if (existing === 'granted-once' || existing === 'granted-always') {\n      result[scope] = existing;\n      continue;\n    }\n    \n    if (existing === 'denied') {\n      result[scope] = 'denied';\n      continue;\n    }\n\n    scopesToRequest.push(scope);\n  }\n\n  let didUpdatePermissions = false;\n\n  if (scopesToRequest.length > 0) {\n    const promptResponse = await openPermissionPrompt({ origin, scopes: scopesToRequest, reason, tools });\n\n    if (promptResponse.granted) {\n      const grantType = promptResponse.grantType || 'granted-once';\n      for (const scope of scopesToRequest) {\n        const grant = {\n          type: grantType as PermissionGrantType,\n          grantedAt: Date.now(),\n          expiresAt: grantType === 'granted-once' ? Date.now() + 10 * 60 * 1000 : undefined,\n        };\n        permissions.scopes[scope] = grant;\n        result[scope] = grant.type;\n      }\n\n      if (promptResponse.allowedTools && promptResponse.allowedTools.length > 0) {\n        permissions.allowedTools = [\n          ...new Set([...(permissions.allowedTools || []), ...promptResponse.allowedTools]),\n        ];\n      }\n\n      didUpdatePermissions = true;\n    } else {\n      for (const scope of scopesToRequest) {\n        if (promptResponse.explicitDeny) {\n          permissions.scopes[scope] = { type: 'denied', grantedAt: Date.now() };\n          result[scope] = 'denied';\n          didUpdatePermissions = true;\n        } else {\n          result[scope] = 'not-granted';\n        }\n      }\n    }\n  }\n\n  if (scopesToRequest.length === 0 && missingTools.length > 0) {\n    const promptResponse = await openPermissionPrompt({\n      origin,\n      scopes: ['mcp:tools.call'],\n      reason,\n      tools: missingTools,\n    });\n\n    if (promptResponse.granted && promptResponse.allowedTools && promptResponse.allowedTools.length > 0) {\n      permissions.allowedTools = [\n        ...new Set([...(permissions.allowedTools || []), ...promptResponse.allowedTools]),\n      ];\n      didUpdatePermissions = true;\n    }\n  }\n\n  if (didUpdatePermissions) {\n    await savePermissions(origin, permissions);\n    \n    // Sync granted permissions to Harbor so it can enforce them\n    const grantedScopes = Object.entries(result)\n      .filter(([, grant]) => grant === 'granted-once' || grant === 'granted-always')\n      .map(([scope]) => scope as PermissionScope);\n    \n    if (grantedScopes.length > 0) {\n      const grantType = result[grantedScopes[0]]; // Use the same grant type\n      try {\n        await harborRequest('system.syncPermissions', {\n          origin,\n          scopes: grantedScopes,\n          grantType,\n          allowedTools: permissions.allowedTools,\n        });\n        console.log('[Web Agents API] Synced permissions to Harbor:', grantedScopes);\n      } catch (e) {\n        console.warn('[Web Agents API] Failed to sync permissions to Harbor:', e);\n        // Continue even if sync fails - local permissions still work\n      }\n    }\n  }\n  \n  const allGranted = scopes.every(s => result[s] === 'granted-once' || result[s] === 'granted-always');\n  \n  return {\n    granted: allGranted,\n    scopes: result,\n    allowedTools: permissions.allowedTools,\n  };\n}\n\n// =============================================================================\n// Message Handlers\n// =============================================================================\n\ninterface RequestContext {\n  id: string;\n  type: string;\n  payload: unknown;\n  origin: string;\n  tabId?: number;\n}\n\ntype HandlerResponse = Promise<TransportResponse>;\n\nasync function handleAiCanCreateTextSession(ctx: RequestContext): HandlerResponse {\n  try {\n    const harborState = getHarborState();\n    if (!harborState.connected) {\n      await discoverHarbor();\n    }\n    \n    const capabilities = await harborRequest<{ bridgeReady: boolean }>('system.getCapabilities');\n    return { id: ctx.id, ok: true, result: capabilities.bridgeReady ? 'readily' : 'no' };\n  } catch {\n    return { id: ctx.id, ok: true, result: 'no' };\n  }\n}\n\nasync function handleAiCreateTextSession(ctx: RequestContext): HandlerResponse {\n  // Check permission\n  if (!await hasPermission(ctx.origin, 'model:prompt')) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Permission model:prompt required' },\n    };\n  }\n\n  const options = (ctx.payload || {}) as Record<string, unknown>;\n  const sessionId = generateSessionId();\n  \n  textSessions.set(sessionId, {\n    sessionId,\n    origin: ctx.origin,\n    options,\n    history: [],\n    createdAt: Date.now(),\n  });\n\n  return { id: ctx.id, ok: true, result: sessionId };\n}\n\nasync function handleSessionPrompt(ctx: RequestContext): HandlerResponse {\n  const { sessionId, input } = ctx.payload as { sessionId: string; input: string };\n  \n  const session = textSessions.get(sessionId);\n  if (!session) {\n    return { id: ctx.id, ok: false, error: { code: 'ERR_SESSION_NOT_FOUND', message: 'Session not found' } };\n  }\n  \n  if (session.origin !== ctx.origin) {\n    return { id: ctx.id, ok: false, error: { code: 'ERR_PERMISSION_DENIED', message: 'Session belongs to different origin' } };\n  }\n\n  try {\n    // Add user message to history\n    session.history.push({ role: 'user', content: input });\n    \n    // Build messages array\n    const messages: Array<{ role: string; content: string }> = [];\n    if (session.options.systemPrompt) {\n      messages.push({ role: 'system', content: session.options.systemPrompt as string });\n    }\n    messages.push(...session.history);\n    \n    // Call Harbor\n    const result = await harborRequest<{ content: string; model?: string }>('llm.chat', {\n      messages,\n      model: session.options.model,\n      temperature: session.options.temperature,\n    });\n    \n    // Add assistant response to history\n    session.history.push({ role: 'assistant', content: result.content });\n    \n    return { id: ctx.id, ok: true, result: result.content };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_MODEL_FAILED', message: e instanceof Error ? e.message : 'LLM request failed' },\n    };\n  }\n}\n\nasync function handleSessionDestroy(ctx: RequestContext): HandlerResponse {\n  const { sessionId } = ctx.payload as { sessionId: string };\n  textSessions.delete(sessionId);\n  return { id: ctx.id, ok: true, result: null };\n}\n\nasync function handleLanguageModelCapabilities(ctx: RequestContext): HandlerResponse {\n  try {\n    const harborState = getHarborState();\n    if (!harborState.connected) {\n      await discoverHarbor();\n    }\n    \n    const capabilities = await harborRequest<{ bridgeReady: boolean }>('system.getCapabilities');\n    return {\n      id: ctx.id,\n      ok: true,\n      result: {\n        available: capabilities.bridgeReady ? 'readily' : 'no',\n        defaultTemperature: 0.7,\n        defaultTopK: 40,\n        maxTopK: 100,\n      },\n    };\n  } catch {\n    return { id: ctx.id, ok: true, result: { available: 'no' } };\n  }\n}\n\nasync function handleProviderslist(ctx: RequestContext): HandlerResponse {\n  if (!await hasPermission(ctx.origin, 'model:list')) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Permission model:list required' },\n    };\n  }\n\n  try {\n    const result = await harborRequest<{ providers: unknown[] }>('llm.listProviders');\n    return { id: ctx.id, ok: true, result: result.providers };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Failed to list providers' },\n    };\n  }\n}\n\nasync function handleProvidersGetActive(ctx: RequestContext): HandlerResponse {\n  try {\n    const result = await harborRequest<{ default_model?: string }>('llm.getActiveProvider');\n    return { id: ctx.id, ok: true, result: { provider: null, model: result.default_model || null } };\n  } catch {\n    return { id: ctx.id, ok: true, result: { provider: null, model: null } };\n  }\n}\n\nasync function handleRequestPermissions(ctx: RequestContext): HandlerResponse {\n  const { scopes, reason, tools } = ctx.payload as {\n    scopes: PermissionScope[];\n    reason?: string;\n    tools?: string[];\n  };\n\n  const result = await showPermissionPrompt(ctx.origin, scopes, reason, tools);\n  return { id: ctx.id, ok: true, result };\n}\n\nasync function handlePermissionsList(ctx: RequestContext): HandlerResponse {\n  const permissions = await getPermissions(ctx.origin);\n  const scopes: Record<string, PermissionGrantType> = {};\n  \n  for (const [scope, grant] of Object.entries(permissions.scopes)) {\n    // Check expiration\n    if (grant.type === 'granted-once' && grant.expiresAt && Date.now() > grant.expiresAt) {\n      scopes[scope] = 'not-granted';\n    } else {\n      scopes[scope] = grant.type;\n    }\n  }\n  \n  return {\n    id: ctx.id,\n    ok: true,\n    result: {\n      origin: ctx.origin,\n      scopes,\n      allowedTools: permissions.allowedTools,\n    },\n  };\n}\n\nasync function handleToolsList(ctx: RequestContext): HandlerResponse {\n  if (!await hasPermission(ctx.origin, 'mcp:tools.list')) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Permission mcp:tools.list required' },\n    };\n  }\n\n  try {\n    const result = await harborRequest<{ tools: unknown[] }>('mcp.listTools', {});\n    return { id: ctx.id, ok: true, result: result.tools };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Failed to list tools' },\n    };\n  }\n}\n\nasync function handleToolsCall(ctx: RequestContext): HandlerResponse {\n  if (!await hasPermission(ctx.origin, 'mcp:tools.call')) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Permission mcp:tools.call required' },\n    };\n  }\n\n  const { tool, args } = ctx.payload as { tool: string; args?: Record<string, unknown> };\n  \n  // Check tool allowlist\n  const permissions = await getPermissions(ctx.origin);\n  if (permissions.allowedTools && !permissions.allowedTools.includes(tool)) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_TOOL_NOT_ALLOWED', message: `Tool ${tool} not in allowlist` },\n    };\n  }\n\n  // Parse tool name (may be \"serverId/toolName\" or just \"toolName\")\n  let serverId: string;\n  let toolName: string;\n  \n  if (tool.includes('/')) {\n    [serverId, toolName] = tool.split('/', 2);\n  } else {\n    // Need to find which server has this tool\n    const toolsResult = await harborRequest<{ tools: Array<{ serverId: string; name: string }> }>('mcp.listTools', {});\n    const found = toolsResult.tools.find(t => t.name === tool);\n    if (!found) {\n      return {\n        id: ctx.id,\n        ok: false,\n        error: { code: 'ERR_TOOL_NOT_FOUND', message: `Tool ${tool} not found` },\n      };\n    }\n    serverId = found.serverId;\n    toolName = tool;\n  }\n\n  try {\n    const result = await harborRequest<{ result: unknown }>('mcp.callTool', {\n      serverId,\n      toolName,\n      args: args || {},\n    });\n    return { id: ctx.id, ok: true, result: result.result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_TOOL_FAILED', message: e instanceof Error ? e.message : 'Tool call failed' },\n    };\n  }\n}\n\n// =============================================================================\n// Session Handlers (Explicit Sessions via Harbor)\n// =============================================================================\n\n/**\n * Create an explicit session with specified capabilities.\n * This proxies to Harbor's session.create endpoint.\n */\nasync function handleSessionsCreate(ctx: RequestContext): HandlerResponse {\n  const options = ctx.payload as CreateSessionOptions;\n  \n  if (!options || !options.capabilities) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INVALID_REQUEST', message: 'Missing capabilities in session options' },\n    };\n  }\n\n  // Check required permissions based on requested capabilities\n  const requiredScopes: PermissionScope[] = [];\n  if (options.capabilities.llm) {\n    requiredScopes.push('model:prompt');\n  }\n  if (options.capabilities.tools && options.capabilities.tools.length > 0) {\n    requiredScopes.push('mcp:tools.call');\n  }\n  // TODO: Add browser permission checks when those scopes are supported\n\n  // Check permissions\n  for (const scope of requiredScopes) {\n    if (!await hasPermission(ctx.origin, scope)) {\n      return {\n        id: ctx.id,\n        ok: false,\n        error: { code: 'ERR_PERMISSION_DENIED', message: `Permission ${scope} required` },\n      };\n    }\n  }\n\n  // Get allowed tools for this origin\n  const permissions = await getPermissions(ctx.origin);\n  const allowedTools = permissions.allowedTools || [];\n\n  try {\n    const result = await harborRequest<{\n      sessionId: string;\n      capabilities: unknown;\n    }>('session.create', {\n      origin: ctx.origin,\n      tabId: ctx.tabId,\n      options,\n    });\n\n    return {\n      id: ctx.id,\n      ok: true,\n      result: {\n        success: true,\n        sessionId: result.sessionId,\n        capabilities: result.capabilities,\n      },\n    };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Session creation failed' },\n    };\n  }\n}\n\n/**\n * Get a session by ID.\n */\nasync function handleSessionsGet(ctx: RequestContext): HandlerResponse {\n  const { sessionId } = ctx.payload as { sessionId: string };\n\n  if (!sessionId) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INVALID_REQUEST', message: 'Missing sessionId' },\n    };\n  }\n\n  try {\n    const result = await harborRequest<{ session: SessionSummary | null }>('session.get', {\n      sessionId,\n      origin: ctx.origin,\n    });\n\n    return { id: ctx.id, ok: true, result: result.session };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_SESSION_NOT_FOUND', message: e instanceof Error ? e.message : 'Session not found' },\n    };\n  }\n}\n\n/**\n * List sessions for the requesting origin.\n */\nasync function handleSessionsList(ctx: RequestContext): HandlerResponse {\n  try {\n    const result = await harborRequest<{ sessions: SessionSummary[] }>('session.list', {\n      origin: ctx.origin,\n      activeOnly: true,\n    });\n\n    return { id: ctx.id, ok: true, result: result.sessions };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Failed to list sessions' },\n    };\n  }\n}\n\n/**\n * Terminate a session.\n */\nasync function handleSessionsTerminate(ctx: RequestContext): HandlerResponse {\n  const { sessionId } = ctx.payload as { sessionId: string };\n\n  if (!sessionId) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INVALID_REQUEST', message: 'Missing sessionId' },\n    };\n  }\n\n  try {\n    const result = await harborRequest<{ terminated: boolean }>('session.terminate', {\n      sessionId,\n      origin: ctx.origin,\n    });\n\n    return { id: ctx.id, ok: true, result: { terminated: result.terminated } };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_SESSION_NOT_FOUND', message: e instanceof Error ? e.message : 'Session not found' },\n    };\n  }\n}\n\n// =============================================================================\n// MCP Server Handlers\n// =============================================================================\n\nasync function handleMcpDiscover(ctx: RequestContext): HandlerResponse {\n  try {\n    const result = await harborRequest<{\n      servers: Array<{\n        url: string;\n        name?: string;\n        description?: string;\n        tools?: string[];\n        transport?: string;\n      }>;\n    }>('agent.mcp.discover', { origin: ctx.origin });\n    return { id: ctx.id, ok: true, result: result.servers || [] };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_MCP_DISCOVER', message: e instanceof Error ? e.message : 'Failed to discover MCP servers' },\n    };\n  }\n}\n\nasync function handleMcpRegister(ctx: RequestContext): HandlerResponse {\n  const { url, name, description, tools, transport } = ctx.payload as {\n    url: string;\n    name: string;\n    description?: string;\n    tools?: string[];\n    transport?: 'sse' | 'stdio' | 'streamable-http';\n  };\n\n  if (!url || !name) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INVALID_REQUEST', message: 'Missing url or name' },\n    };\n  }\n\n  try {\n    const result = await harborRequest<{\n      success: boolean;\n      serverId?: string;\n      error?: { code: string; message: string };\n    }>('agent.mcp.register', {\n      origin: ctx.origin,\n      url,\n      name,\n      description,\n      tools,\n      transport,\n    });\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_MCP_REGISTER', message: e instanceof Error ? e.message : 'Failed to register MCP server' },\n    };\n  }\n}\n\nasync function handleMcpUnregister(ctx: RequestContext): HandlerResponse {\n  const { serverId } = ctx.payload as { serverId: string };\n\n  if (!serverId) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INVALID_REQUEST', message: 'Missing serverId' },\n    };\n  }\n\n  try {\n    const result = await harborRequest<{ success: boolean }>('agent.mcp.unregister', {\n      origin: ctx.origin,\n      serverId,\n    });\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_MCP_UNREGISTER', message: e instanceof Error ? e.message : 'Failed to unregister MCP server' },\n    };\n  }\n}\n\n// =============================================================================\n// Chat API Handlers\n// =============================================================================\n\nasync function handleChatCanOpen(ctx: RequestContext): HandlerResponse {\n  try {\n    const result = await harborRequest<{ available: boolean; reason?: string }>('agent.chat.canOpen', {\n      origin: ctx.origin,\n    });\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_CHAT', message: e instanceof Error ? e.message : 'Failed to check chat availability' },\n    };\n  }\n}\n\nasync function handleChatOpen(ctx: RequestContext): HandlerResponse {\n  const { systemPrompt, initialMessage, tools, style } = (ctx.payload || {}) as {\n    systemPrompt?: string;\n    initialMessage?: string;\n    tools?: string[];\n    style?: {\n      theme?: 'light' | 'dark' | 'auto';\n      accentColor?: string;\n      position?: 'right' | 'left';\n    };\n  };\n\n  try {\n    const result = await harborRequest<{\n      success: boolean;\n      chatId?: string;\n      error?: { code: string; message: string };\n    }>('agent.chat.open', {\n      origin: ctx.origin,\n      tabId: ctx.tabId,\n      systemPrompt,\n      initialMessage,\n      tools,\n      style,\n    });\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_CHAT_OPEN', message: e instanceof Error ? e.message : 'Failed to open chat' },\n    };\n  }\n}\n\nasync function handleChatClose(ctx: RequestContext): HandlerResponse {\n  const { chatId } = ctx.payload as { chatId: string };\n\n  if (!chatId) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INVALID_REQUEST', message: 'Missing chatId' },\n    };\n  }\n\n  try {\n    const result = await harborRequest<{ success: boolean }>('agent.chat.close', {\n      origin: ctx.origin,\n      chatId,\n    });\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_CHAT_CLOSE', message: e instanceof Error ? e.message : 'Failed to close chat' },\n    };\n  }\n}\n\n// =============================================================================\n// Multi-Agent Handlers\n// =============================================================================\n\n// Track registered agents from this extension\nconst registeredAgents = new Map<string, {\n  agentId: string;\n  origin: string;\n  tabId: number;\n  name: string;\n  capabilities: string[];\n}>();\n\n// Track pending invocations waiting for responses from pages\nconst pendingInvocations = new Map<string, {\n  resolve: (response: unknown) => void;\n  reject: (error: Error) => void;\n  timeout: ReturnType<typeof setTimeout>;\n}>();\n\n// Track tabs that have invocation handlers set up (agentId -> tabId)\nconst agentInvocationTabs = new Map<string, number>();\n\n/**\n * Register a proxy invocation handler with Harbor for an agent.\n * This allows invocations to be routed through Web Agents API to the page.\n */\nasync function registerProxyInvocationHandler(agentId: string, origin: string, tabId: number): Promise<void> {\n  console.log('[Web Agents API] registerProxyInvocationHandler called:', { agentId, origin, tabId });\n  \n  // Track which tab this agent's handler should go to\n  if (tabId > 0) {\n    agentInvocationTabs.set(agentId, tabId);\n    console.log('[Web Agents API] Stored tab mapping:', agentId, '->', tabId);\n  }\n  \n  // Check Harbor connection first\n  const harborState = getHarborState();\n  console.log('[Web Agents API] Harbor state:', harborState);\n  \n  if (!harborState.connected) {\n    console.warn('[Web Agents API] Harbor not connected, trying to discover...');\n    const id = await discoverHarbor();\n    if (!id) {\n      console.error('[Web Agents API] Cannot register invocation handler - Harbor not found');\n      return;\n    }\n  }\n  \n  // Tell Harbor this agent has an invocation handler\n  try {\n    console.log('[Web Agents API] Sending agents.registerInvocationHandler to Harbor...');\n    const result = await harborRequest('agents.registerInvocationHandler', { \n      agentId, \n      origin,\n      tabId,\n    });\n    console.log('[Web Agents API] Harbor response for registerInvocationHandler:', result);\n  } catch (e) {\n    console.error('[Web Agents API] Failed to register proxy handler with Harbor:', e);\n  }\n}\n\n/**\n * Handle an invocation request from Harbor for one of our registered agents.\n * Forward it to the correct tab and wait for response.\n */\nasync function handleIncomingInvocation(\n  agentId: string,\n  request: { from: string; task: string; input?: unknown; timeout?: number },\n  traceId?: string\n): Promise<{ success: boolean; result?: unknown; error?: { code: string; message: string } }> {\n  const trace = traceId || 'no-trace';\n  \n  // Try to find tabId from multiple sources\n  let tabId = agentInvocationTabs.get(agentId);\n  \n  if (!tabId) {\n    // Try to get from registered agents\n    const agent = registeredAgents.get(agentId);\n    if (agent?.tabId) {\n      tabId = agent.tabId;\n    }\n  }\n  \n  console.log(`[TRACE ${trace}] handleIncomingInvocation - agentId: ${agentId}, tabId: ${tabId}, task: ${request.task}`);\n  \n  if (!tabId) {\n    console.log(`[TRACE ${trace}] handleIncomingInvocation ERROR - no tab`);\n    return { success: false, error: { code: 'ERR_NO_TAB', message: 'Agent tab not found' } };\n  }\n  \n  const invocationId = `inv-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n  const timeout = request.timeout || 30000;\n  \n  console.log(`[TRACE ${trace}] Sending to tab ${tabId} with invocationId: ${invocationId}`);\n  \n  return new Promise((resolve) => {\n    // Set up timeout\n    const timeoutId = setTimeout(() => {\n      pendingInvocations.delete(invocationId);\n      resolve({ success: false, error: { code: 'ERR_TIMEOUT', message: 'Invocation timed out' } });\n    }, timeout);\n    \n    // Store pending invocation\n    pendingInvocations.set(invocationId, {\n      resolve: (response) => {\n        clearTimeout(timeoutId);\n        pendingInvocations.delete(invocationId);\n        resolve(response as { success: boolean; result?: unknown; error?: { code: string; message: string } });\n      },\n      reject: (error) => {\n        clearTimeout(timeoutId);\n        pendingInvocations.delete(invocationId);\n        resolve({ success: false, error: { code: 'ERR_FAILED', message: error.message } });\n      },\n      timeout: timeoutId,\n    });\n    \n    // Send invocation to the tab\n    chrome.tabs.sendMessage(tabId, {\n      type: 'agentInvocation',\n      invocationId,\n      agentId,\n      from: request.from,\n      task: request.task,\n      input: request.input,\n      traceId: trace,\n    }).catch((error) => {\n      console.log(`[TRACE ${trace}] tabs.sendMessage ERROR: ${error.message}`);\n      clearTimeout(timeoutId);\n      pendingInvocations.delete(invocationId);\n      resolve({ success: false, error: { code: 'ERR_SEND_FAILED', message: error.message } });\n    });\n  });\n}\n\n/**\n * Register an agent.\n */\nasync function handleAgentsRegister(ctx: RequestContext): HandlerResponse {\n  const options = ctx.payload as {\n    name: string;\n    description?: string;\n    capabilities?: string[];\n    tags?: string[];\n    acceptsInvocations?: boolean;\n    acceptsMessages?: boolean;\n  };\n\n  if (!options.name) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INVALID_REQUEST', message: 'Missing name' },\n    };\n  }\n\n  try {\n    const result = await harborRequest<{\n      id: string;\n      name: string;\n      description?: string;\n      capabilities: string[];\n      tags: string[];\n      status: string;\n      origin: string;\n      acceptsInvocations: boolean;\n      acceptsMessages: boolean;\n      registeredAt: number;\n      lastActiveAt: number;\n    }>('agents.register', {\n      ...options,\n      origin: ctx.origin,\n      tabId: ctx.tabId,\n    });\n\n    // Track locally - use tabId from context or try to find it\n    const tabId = ctx.tabId;\n    console.log('[Web Agents API] Agent registered:', result.id, 'tabId:', tabId, 'acceptsInvocations:', result.acceptsInvocations);\n    \n    // Always track the agent\n    registeredAgents.set(result.id, {\n      agentId: result.id,\n      origin: ctx.origin,\n      tabId: tabId || 0, // Will be updated if we get tabId later\n      name: result.name,\n      capabilities: result.capabilities,\n    });\n    \n    // If agent accepts invocations, register a proxy handler with Harbor\n    // We'll pass the origin so Harbor can route back to us\n    if (result.acceptsInvocations) {\n      await registerProxyInvocationHandler(result.id, ctx.origin, tabId || 0);\n    }\n\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Registration failed' },\n    };\n  }\n}\n\n/**\n * Unregister an agent.\n */\nasync function handleAgentsUnregister(ctx: RequestContext): HandlerResponse {\n  const { agentId } = ctx.payload as { agentId: string };\n\n  if (!agentId) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INVALID_REQUEST', message: 'Missing agentId' },\n    };\n  }\n\n  try {\n    await harborRequest('agents.unregister', { agentId, origin: ctx.origin });\n    registeredAgents.delete(agentId);\n    return { id: ctx.id, ok: true, result: null };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Unregistration failed' },\n    };\n  }\n}\n\n/**\n * Get agent info.\n */\nasync function handleAgentsGetInfo(ctx: RequestContext): HandlerResponse {\n  const { agentId } = ctx.payload as { agentId: string };\n\n  if (!agentId) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INVALID_REQUEST', message: 'Missing agentId' },\n    };\n  }\n\n  try {\n    const result = await harborRequest('agents.getInfo', { agentId, origin: ctx.origin });\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_AGENT_NOT_FOUND', message: e instanceof Error ? e.message : 'Agent not found' },\n    };\n  }\n}\n\n/**\n * Discover agents.\n */\nasync function handleAgentsDiscover(ctx: RequestContext): HandlerResponse {\n  const query = ctx.payload as {\n    name?: string;\n    capabilities?: string[];\n    tags?: string[];\n    includeSameOrigin?: boolean;\n    includeCrossOrigin?: boolean;\n  };\n\n  try {\n    const result = await harborRequest<{ agents: unknown[]; total: number }>('agents.discover', {\n      ...query,\n      origin: ctx.origin,\n    });\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Discovery failed' },\n    };\n  }\n}\n\n/**\n * List all agents.\n */\nasync function handleAgentsList(ctx: RequestContext): HandlerResponse {\n  try {\n    const result = await harborRequest<{ agents: unknown[] }>('agents.list', { origin: ctx.origin });\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'List failed' },\n    };\n  }\n}\n\n/**\n * Invoke an agent.\n */\nasync function handleAgentsInvoke(ctx: RequestContext): HandlerResponse {\n  const { agentId, request } = ctx.payload as {\n    agentId: string;\n    request: { task: string; input?: unknown; timeout?: number };\n  };\n\n  // Generate trace ID for this invocation\n  const traceId = `trace-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;\n  console.log(`[TRACE ${traceId}] handleAgentsInvoke START - agentId: ${agentId}, task: ${request?.task}`);\n\n  if (!agentId || !request) {\n    console.log(`[TRACE ${traceId}] handleAgentsInvoke ERROR - missing params`);\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INVALID_REQUEST', message: 'Missing agentId or request' },\n    };\n  }\n\n  try {\n    // Flatten the request for Harbor - it expects { agentId, task, input, timeout }\n    console.log(`[TRACE ${traceId}] Sending to Harbor...`);\n    const result = await harborRequest<{\n      success: boolean;\n      result?: unknown;\n      error?: { code: string; message: string };\n      executionTime?: number;\n    }>('agents.invoke', {\n      agentId,\n      task: request.task,\n      input: request.input,\n      timeout: request.timeout,\n      origin: ctx.origin,\n      tabId: ctx.tabId,\n      traceId, // Pass trace ID to Harbor\n    });\n    console.log(`[TRACE ${traceId}] Harbor response received, success: ${result?.success}`);\n\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Invocation failed' },\n    };\n  }\n}\n\n/**\n * Send a message to an agent.\n */\nasync function handleAgentsSend(ctx: RequestContext): HandlerResponse {\n  const { agentId, payload } = ctx.payload as { agentId: string; payload: unknown };\n\n  if (!agentId) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INVALID_REQUEST', message: 'Missing agentId' },\n    };\n  }\n\n  try {\n    const result = await harborRequest<{ delivered: boolean }>('agents.send', {\n      agentId,\n      payload,\n      origin: ctx.origin,\n      tabId: ctx.tabId,\n    });\n\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Send failed' },\n    };\n  }\n}\n\n/**\n * Subscribe to events.\n */\nasync function handleAgentsSubscribe(ctx: RequestContext): HandlerResponse {\n  const { eventType } = ctx.payload as { eventType: string };\n\n  if (!eventType) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INVALID_REQUEST', message: 'Missing eventType' },\n    };\n  }\n\n  try {\n    await harborRequest('agents.subscribe', {\n      eventType,\n      origin: ctx.origin,\n      tabId: ctx.tabId,\n    });\n\n    return { id: ctx.id, ok: true, result: null };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Subscribe failed' },\n    };\n  }\n}\n\n/**\n * Unsubscribe from events.\n */\nasync function handleAgentsUnsubscribe(ctx: RequestContext): HandlerResponse {\n  const { eventType } = ctx.payload as { eventType: string };\n\n  if (!eventType) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INVALID_REQUEST', message: 'Missing eventType' },\n    };\n  }\n\n  try {\n    await harborRequest('agents.unsubscribe', {\n      eventType,\n      origin: ctx.origin,\n      tabId: ctx.tabId,\n    });\n\n    return { id: ctx.id, ok: true, result: null };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Unsubscribe failed' },\n    };\n  }\n}\n\n/**\n * Broadcast an event.\n */\nasync function handleAgentsBroadcast(ctx: RequestContext): HandlerResponse {\n  const { eventType, data } = ctx.payload as { eventType: string; data: unknown };\n\n  if (!eventType) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INVALID_REQUEST', message: 'Missing eventType' },\n    };\n  }\n\n  try {\n    const result = await harborRequest<{ delivered: number }>('agents.broadcast', {\n      eventType,\n      data,\n      origin: ctx.origin,\n      tabId: ctx.tabId,\n    });\n\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Broadcast failed' },\n    };\n  }\n}\n\n/**\n * Execute a pipeline.\n */\nasync function handleAgentsPipeline(ctx: RequestContext): HandlerResponse {\n  const { config, initialInput } = ctx.payload as {\n    config: { steps: Array<{ agentId: string; task: string; inputTransform?: string; outputTransform?: string }> };\n    initialInput: unknown;\n  };\n\n  if (!config?.steps?.length) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INVALID_REQUEST', message: 'Missing pipeline steps' },\n    };\n  }\n\n  try {\n    const result = await harborRequest<{\n      success: boolean;\n      result: unknown;\n      stepResults: unknown[];\n    }>('agents.orchestrate.pipeline', {\n      config,\n      initialInput,\n      origin: ctx.origin,\n    });\n\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Pipeline failed' },\n    };\n  }\n}\n\n/**\n * Execute parallel tasks.\n */\nasync function handleAgentsParallel(ctx: RequestContext): HandlerResponse {\n  const { config } = ctx.payload as {\n    config: {\n      tasks: Array<{ agentId: string; task: string; input?: unknown }>;\n      combineStrategy?: 'array' | 'merge' | 'first';\n    };\n  };\n\n  if (!config?.tasks?.length) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INVALID_REQUEST', message: 'Missing parallel tasks' },\n    };\n  }\n\n  try {\n    const result = await harborRequest<{\n      success: boolean;\n      results: unknown[];\n      combined: unknown;\n    }>('agents.orchestrate.parallel', {\n      config,\n      origin: ctx.origin,\n    });\n\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Parallel execution failed' },\n    };\n  }\n}\n\n/**\n * Route to an agent.\n */\nasync function handleAgentsRoute(ctx: RequestContext): HandlerResponse {\n  const { config, input, task } = ctx.payload as {\n    config: {\n      routes: Array<{ condition: string; agentId: string }>;\n      defaultAgentId?: string;\n    };\n    input: unknown;\n    task: string;\n  };\n\n  if (!config?.routes?.length) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INVALID_REQUEST', message: 'Missing routes' },\n    };\n  }\n\n  try {\n    const result = await harborRequest<{\n      success: boolean;\n      result?: unknown;\n      error?: { code: string; message: string };\n    }>('agents.orchestrate.route', {\n      config,\n      input,\n      task,\n      origin: ctx.origin,\n    });\n\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Routing failed' },\n    };\n  }\n}\n\n// Clean up agents when tabs close\nchrome.tabs.onRemoved.addListener((tabId) => {\n  for (const [agentId, agent] of registeredAgents.entries()) {\n    if (agent.tabId === tabId) {\n      registeredAgents.delete(agentId);\n      // Notify Harbor of cleanup\n      harborRequest('agents.unregister', { agentId, origin: agent.origin }).catch(() => {});\n    }\n  }\n});\n\n// =============================================================================\n// Agent Run Handler (Agentic Loop)\n// =============================================================================\n\ninterface AgentRunEvent {\n  type: 'thinking' | 'tool_call' | 'tool_result' | 'final' | 'error';\n  content?: string;\n  tool?: string;\n  args?: Record<string, unknown>;\n  result?: unknown;\n  output?: string;\n  error?: string;\n}\n\nasync function handleAgentRun(\n  ctx: RequestContext,\n  sendEvent: (event: TransportStreamEvent) => void,\n): Promise<void> {\n  const { task, maxToolCalls = 5, systemPrompt } = ctx.payload as {\n    task: string;\n    maxToolCalls?: number;\n    systemPrompt?: string;\n  };\n\n  console.log('[Web Agents API] agent.run starting:', { task, maxToolCalls, origin: ctx.origin });\n\n  // Check permissions\n  if (!await hasPermission(ctx.origin, 'model:prompt')) {\n    console.log('[Web Agents API] agent.run: Missing model:prompt permission');\n    sendEvent({\n      id: ctx.id,\n      event: { type: 'error', error: { code: 'ERR_PERMISSION_DENIED', message: 'Permission model:prompt required' } },\n      done: true,\n    });\n    return;\n  }\n\n  try {\n    // Get available tools\n    let tools: Array<{ serverId: string; name: string; description?: string; inputSchema?: unknown }> = [];\n    \n    const hasToolsListPerm = await hasPermission(ctx.origin, 'mcp:tools.list');\n    console.log('[Web Agents API] agent.run: mcp:tools.list permission:', hasToolsListPerm);\n    \n    if (hasToolsListPerm) {\n      const toolsResult = await harborRequest<{ tools: typeof tools }>('mcp.listTools', {});\n      tools = toolsResult.tools || [];\n      console.log('[Web Agents API] agent.run: Found', tools.length, 'tools');\n      \n      // Filter to allowed tools (only if there's an explicit allowlist)\n      const permissions = await getPermissions(ctx.origin);\n      if (permissions.allowedTools && permissions.allowedTools.length > 0) {\n        tools = tools.filter(t => \n          permissions.allowedTools!.includes(t.name) || \n          permissions.allowedTools!.includes(`${t.serverId}/${t.name}`)\n        );\n        console.log('[Web Agents API] agent.run: After filtering:', tools.length, 'tools');\n      }\n    }\n\n    // Build tool definitions for the LLM (bridge expects {name, description, input_schema})\n    const llmTools = tools.map(t => ({\n      name: `${t.serverId}_${t.name}`.replace(/[^a-zA-Z0-9_]/g, '_'), // LLM-safe name\n      description: t.description || `Tool: ${t.serverId}/${t.name}`,\n      input_schema: t.inputSchema || { type: 'object', properties: {} },\n      // Keep original info for later\n      _serverId: t.serverId,\n      _toolName: t.name,\n    }));\n\n    console.log('[Web Agents API] agent.run: LLM tools:', llmTools.map(t => t.name));\n\n    // Send thinking event with available tools\n    if (llmTools.length > 0) {\n      sendEvent({\n        id: ctx.id,\n        event: { type: 'token', token: JSON.stringify({ \n          type: 'thinking', \n          content: `Available tools: ${tools.map(t => `${t.serverId}/${t.name}`).join(', ')}` \n        }) },\n      });\n    } else {\n      sendEvent({\n        id: ctx.id,\n        event: { type: 'token', token: JSON.stringify({ \n          type: 'thinking', \n          content: 'No tools available (check mcp:tools.list permission)' \n        }) },\n      });\n    }\n\n    // Agentic loop - use native tool calling\n    const messages: Array<{ role: string; content: string }> = [];\n    const fullSystemPrompt = systemPrompt || 'You are a helpful assistant that can use tools to help users.';\n\n    messages.push({ role: 'system', content: fullSystemPrompt });\n    messages.push({ role: 'user', content: task });\n\n    let toolCallCount = 0;\n\n    while (toolCallCount < maxToolCalls) {\n      // Call LLM with tools (native tool calling)\n      console.log('[Web Agents API] agent.run: Calling LLM with', messages.length, 'messages and', llmTools.length, 'tools');\n      \n      type LLMResponse = {\n        content?: string;\n        choices?: Array<{\n          message: {\n            role: string;\n            content: string;\n            tool_calls?: Array<{ id: string; function: { name: string; arguments: string } }>;\n          };\n          finish_reason?: string;\n        }>;\n      };\n      \n      let result: LLMResponse;\n      try {\n        result = await harborRequest<LLMResponse>('llm.chat', { \n          messages,\n          tools: llmTools.length > 0 ? llmTools.map(t => ({\n            name: t.name,\n            description: t.description,\n            input_schema: t.input_schema,\n          })) : undefined,\n        });\n        console.log('[Web Agents API] agent.run: LLM result:', JSON.stringify(result).substring(0, 500));\n      } catch (e) {\n        console.error('[Web Agents API] agent.run: LLM request failed:', e);\n        sendEvent({\n          id: ctx.id,\n          event: { type: 'token', token: JSON.stringify({ type: 'error', error: `LLM request failed: ${e}` }) },\n        });\n        sendEvent({ id: ctx.id, event: { type: 'done' }, done: true });\n        return;\n      }\n\n      // Extract response - handle both formats (direct content or choices array)\n      const choice = result.choices?.[0];\n      const responseContent = choice?.message?.content || result.content || '';\n      const toolCalls = choice?.message?.tool_calls;\n      \n      console.log('[Web Agents API] agent.run: Response content:', responseContent?.substring(0, 200));\n      console.log('[Web Agents API] agent.run: Tool calls:', toolCalls);\n\n      // If there are tool calls, execute them\n      if (toolCalls && toolCalls.length > 0) {\n        // Check if we can call tools\n        const hasToolsCallPerm = await hasPermission(ctx.origin, 'mcp:tools.call');\n        if (!hasToolsCallPerm) {\n          messages.push({ role: 'assistant', content: responseContent || 'I need to use tools but permission was denied.' });\n          messages.push({ role: 'user', content: 'Tool calling is not permitted. Please provide an answer without using tools.' });\n          continue;\n        }\n\n        // Process each tool call\n        for (const tc of toolCalls) {\n          const llmToolName = tc.function.name;\n          let args: Record<string, unknown> = {};\n          try {\n            args = JSON.parse(tc.function.arguments || '{}');\n          } catch {\n            args = {};\n          }\n\n          // Find the original tool info\n          const toolInfo = llmTools.find(t => t.name === llmToolName);\n          const serverId = toolInfo?._serverId || '';\n          const actualToolName = toolInfo?._toolName || llmToolName;\n          const displayName = `${serverId}/${actualToolName}`;\n\n          console.log('[Web Agents API] agent.run: Calling tool:', displayName, 'with args:', args);\n\n          // Send tool_call event\n          sendEvent({\n            id: ctx.id,\n            event: { type: 'token', token: JSON.stringify({ type: 'tool_call', tool: displayName, args }) },\n          });\n\n          // Call the tool\n          let toolResult: unknown;\n          try {\n            const callResult = await harborRequest<{ result: unknown }>('mcp.callTool', {\n              serverId,\n              toolName: actualToolName,\n              args,\n            });\n            toolResult = callResult.result;\n            console.log('[Web Agents API] agent.run: Tool result:', toolResult);\n          } catch (e) {\n            console.error('[Web Agents API] agent.run: Tool call failed:', e);\n            toolResult = { error: e instanceof Error ? e.message : 'Tool call failed' };\n          }\n\n          // Send tool_result event\n          sendEvent({\n            id: ctx.id,\n            event: { type: 'token', token: JSON.stringify({ type: 'tool_result', tool: displayName, result: toolResult }) },\n          });\n\n          // Add tool call and result to messages\n          // WORKAROUND: Encode tool call info in assistant message since some bridges don't support tool_calls\n          messages.push({ \n            role: 'assistant', \n            content: `[Called tool: ${displayName}(${JSON.stringify(args)})]` \n          });\n          messages.push({ \n            role: 'user', \n            content: `Tool \"${displayName}\" returned: ${JSON.stringify(toolResult)}` \n          });\n\n          toolCallCount++;\n        }\n      } else {\n        // No tool calls, this is the final response\n        console.log('[Web Agents API] agent.run: Final response (no tool calls)');\n        sendEvent({\n          id: ctx.id,\n          event: { type: 'token', token: JSON.stringify({ type: 'final', output: responseContent }) },\n        });\n        sendEvent({ id: ctx.id, event: { type: 'done' }, done: true });\n        return;\n      }\n    }\n\n    // Max tool calls reached, get final answer\n    console.log('[Web Agents API] agent.run: Max tool calls reached, getting final answer');\n    messages.push({ role: 'user', content: 'Please provide your final answer based on the information gathered.' });\n    const finalResult = await harborRequest<{ content?: string; choices?: Array<{ message: { content: string } }> }>('llm.chat', { messages });\n    const finalContent = finalResult.choices?.[0]?.message?.content || finalResult.content || '';\n    \n    sendEvent({\n      id: ctx.id,\n      event: { type: 'token', token: JSON.stringify({ type: 'final', output: finalContent }) },\n    });\n    sendEvent({ id: ctx.id, event: { type: 'done' }, done: true });\n\n  } catch (e) {\n    console.error('[Web Agents API] agent.run: Error:', e);\n    sendEvent({\n      id: ctx.id,\n      event: { type: 'error', error: { code: 'ERR_AGENT_FAILED', message: e instanceof Error ? e.message : 'Agent run failed' } },\n      done: true,\n    });\n  }\n}\n\n// =============================================================================\n// Streaming Handler\n// =============================================================================\n\nasync function handleSessionPromptStreaming(\n  ctx: RequestContext,\n  sendEvent: (event: TransportStreamEvent) => void,\n): Promise<void> {\n  const { sessionId, input } = ctx.payload as { sessionId: string; input: string };\n  \n  const session = textSessions.get(sessionId);\n  if (!session) {\n    sendEvent({ id: ctx.id, event: { type: 'error', error: { code: 'ERR_SESSION_NOT_FOUND', message: 'Session not found' } }, done: true });\n    return;\n  }\n  \n  if (session.origin !== ctx.origin) {\n    sendEvent({ id: ctx.id, event: { type: 'error', error: { code: 'ERR_PERMISSION_DENIED', message: 'Session belongs to different origin' } }, done: true });\n    return;\n  }\n\n  try {\n    // Add user message to history\n    session.history.push({ role: 'user', content: input });\n    \n    // Build messages array\n    const messages: Array<{ role: string; content: string }> = [];\n    if (session.options.systemPrompt) {\n      messages.push({ role: 'system', content: session.options.systemPrompt as string });\n    }\n    messages.push(...session.history);\n    \n    // Stream from Harbor\n    const { stream, cancel } = harborStreamRequest('llm.chatStream', {\n      messages,\n      model: session.options.model,\n      temperature: session.options.temperature,\n    });\n\n    let fullContent = '';\n    \n    for await (const event of stream) {\n      if (event.type === 'token' && event.token) {\n        fullContent += event.token;\n        sendEvent({ id: ctx.id, event: { type: 'token', token: event.token } });\n      } else if (event.type === 'done') {\n        // Add assistant response to history\n        session.history.push({ role: 'assistant', content: fullContent });\n        sendEvent({ id: ctx.id, event: { type: 'done' }, done: true });\n        break;\n      } else if (event.type === 'error') {\n        sendEvent({ \n          id: ctx.id, \n          event: { type: 'error', error: { code: 'ERR_MODEL_FAILED', message: event.error?.message || 'Stream error' } }, \n          done: true \n        });\n        break;\n      }\n    }\n  } catch (e) {\n    sendEvent({\n      id: ctx.id,\n      event: { type: 'error', error: { code: 'ERR_MODEL_FAILED', message: e instanceof Error ? e.message : 'Streaming failed' } },\n      done: true,\n    });\n  }\n}\n\n// =============================================================================\n// Browser Interaction Handlers\n// =============================================================================\n\n/**\n * Find an element by selector/ref and click it.\n */\nasync function handleBrowserClick(ctx: RequestContext): HandlerResponse {\n  if (!await hasPermission(ctx.origin, 'browser:activeTab.interact')) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Permission browser:activeTab.interact required' },\n    };\n  }\n\n  const { ref } = ctx.payload as { ref: string };\n  if (!ref) {\n    return { id: ctx.id, ok: false, error: { code: 'ERR_INVALID_REQUEST', message: 'Missing ref parameter' } };\n  }\n\n  if (!ctx.tabId) {\n    return { id: ctx.id, ok: false, error: { code: 'ERR_INTERNAL', message: 'No tab context available' } };\n  }\n\n  try {\n    const result = await executeScriptInTab<{ success: boolean; error?: string }>(\n      ctx.tabId,\n      (selector: string) => {\n        const el = document.querySelector(selector);\n        if (!el) {\n          return { success: false, error: `Element not found: ${selector}` };\n        }\n        if (el instanceof HTMLElement) {\n          // Check if element is disabled\n          if ((el as HTMLButtonElement).disabled) {\n            return { success: false, error: `Element is disabled: ${selector}` };\n          }\n          el.click();\n          // For checkboxes/radios, ensure change event fires for form validation\n          if (el instanceof HTMLInputElement && (el.type === 'checkbox' || el.type === 'radio')) {\n            el.dispatchEvent(new Event('change', { bubbles: true }));\n          }\n          return { success: true };\n        }\n        return { success: false, error: 'Element is not clickable' };\n      },\n      [ref]\n    );\n\n    if (!result) {\n      return { id: ctx.id, ok: false, error: { code: 'ERR_INTERNAL', message: 'Script execution failed' } };\n    }\n    if (!result.success) {\n      return { id: ctx.id, ok: false, error: { code: 'ERR_ELEMENT_NOT_FOUND', message: result.error || 'Click failed' } };\n    }\n    return { id: ctx.id, ok: true, result: { success: true } };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Click failed' },\n    };\n  }\n}\n\n/**\n * Find an element by selector/ref and fill it with a value.\n */\nasync function handleBrowserFill(ctx: RequestContext): HandlerResponse {\n  if (!await hasPermission(ctx.origin, 'browser:activeTab.interact')) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Permission browser:activeTab.interact required' },\n    };\n  }\n\n  const { ref, value } = ctx.payload as { ref: string; value: string };\n  if (!ref) {\n    return { id: ctx.id, ok: false, error: { code: 'ERR_INVALID_REQUEST', message: 'Missing ref parameter' } };\n  }\n\n  if (!ctx.tabId) {\n    return { id: ctx.id, ok: false, error: { code: 'ERR_INTERNAL', message: 'No tab context available' } };\n  }\n\n  try {\n    const result = await executeScriptInTab<{ success: boolean; error?: string }>(\n      ctx.tabId,\n      (selector: string, fillValue: string) => {\n        const el = document.querySelector(selector);\n        if (!el) {\n          return { success: false, error: `Element not found: ${selector}` };\n        }\n        if (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement) {\n          el.value = fillValue;\n          el.dispatchEvent(new Event('input', { bubbles: true }));\n          el.dispatchEvent(new Event('change', { bubbles: true }));\n          return { success: true };\n        }\n        if (el instanceof HTMLElement && el.isContentEditable) {\n          el.textContent = fillValue;\n          el.dispatchEvent(new Event('input', { bubbles: true }));\n          return { success: true };\n        }\n        return { success: false, error: 'Element is not fillable' };\n      },\n      [ref, value ?? '']\n    );\n\n    if (!result) {\n      return { id: ctx.id, ok: false, error: { code: 'ERR_INTERNAL', message: 'Script execution failed' } };\n    }\n    if (!result.success) {\n      return { id: ctx.id, ok: false, error: { code: 'ERR_ELEMENT_NOT_FOUND', message: result.error || 'Fill failed' } };\n    }\n    return { id: ctx.id, ok: true, result: { success: true } };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Fill failed' },\n    };\n  }\n}\n\n/**\n * Select an option from a dropdown by selector/ref.\n */\nasync function handleBrowserSelect(ctx: RequestContext): HandlerResponse {\n  if (!await hasPermission(ctx.origin, 'browser:activeTab.interact')) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Permission browser:activeTab.interact required' },\n    };\n  }\n\n  const { ref, value } = ctx.payload as { ref: string; value: string };\n  if (!ref) {\n    return { id: ctx.id, ok: false, error: { code: 'ERR_INVALID_REQUEST', message: 'Missing ref parameter' } };\n  }\n\n  if (!ctx.tabId) {\n    return { id: ctx.id, ok: false, error: { code: 'ERR_INTERNAL', message: 'No tab context available' } };\n  }\n\n  try {\n    const result = await executeScriptInTab<{ success: boolean; error?: string }>(\n      ctx.tabId,\n      (selector: string, selectValue: string) => {\n        const el = document.querySelector(selector);\n        if (!el) {\n          return { success: false, error: `Element not found: ${selector}` };\n        }\n        if (el instanceof HTMLSelectElement) {\n          el.value = selectValue;\n          el.dispatchEvent(new Event('change', { bubbles: true }));\n          return { success: true };\n        }\n        return { success: false, error: 'Element is not a select' };\n      },\n      [ref, value ?? '']\n    );\n\n    if (!result) {\n      return { id: ctx.id, ok: false, error: { code: 'ERR_INTERNAL', message: 'Script execution failed' } };\n    }\n    if (!result.success) {\n      return { id: ctx.id, ok: false, error: { code: 'ERR_ELEMENT_NOT_FOUND', message: result.error || 'Select failed' } };\n    }\n    return { id: ctx.id, ok: true, result: { success: true } };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Select failed' },\n    };\n  }\n}\n\n/**\n * Scroll the page in a direction.\n */\nasync function handleBrowserScroll(ctx: RequestContext): HandlerResponse {\n  if (!await hasPermission(ctx.origin, 'browser:activeTab.interact')) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Permission browser:activeTab.interact required' },\n    };\n  }\n\n  const { direction, amount } = ctx.payload as { direction: 'up' | 'down' | 'left' | 'right'; amount?: number };\n  if (!direction) {\n    return { id: ctx.id, ok: false, error: { code: 'ERR_INVALID_REQUEST', message: 'Missing direction parameter' } };\n  }\n\n  if (!ctx.tabId) {\n    return { id: ctx.id, ok: false, error: { code: 'ERR_INTERNAL', message: 'No tab context available' } };\n  }\n\n  try {\n    const result = await executeScriptInTab<{ success: boolean }>(\n      ctx.tabId,\n      (dir: string, scrollAmount: number) => {\n        const px = scrollAmount || 300;\n        switch (dir) {\n          case 'up':\n            window.scrollBy(0, -px);\n            break;\n          case 'down':\n            window.scrollBy(0, px);\n            break;\n          case 'left':\n            window.scrollBy(-px, 0);\n            break;\n          case 'right':\n            window.scrollBy(px, 0);\n            break;\n        }\n        return { success: true };\n      },\n      [direction, amount ?? 300]\n    );\n\n    if (!result) {\n      return { id: ctx.id, ok: false, error: { code: 'ERR_INTERNAL', message: 'Script execution failed' } };\n    }\n    return { id: ctx.id, ok: true, result: { success: true } };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Scroll failed' },\n    };\n  }\n}\n\n/**\n * Take a screenshot of the active tab.\n */\nasync function handleBrowserScreenshot(ctx: RequestContext): HandlerResponse {\n  if (!await hasPermission(ctx.origin, 'browser:activeTab.screenshot')) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Permission browser:activeTab.screenshot required' },\n    };\n  }\n\n  if (!ctx.tabId) {\n    return { id: ctx.id, ok: false, error: { code: 'ERR_INTERNAL', message: 'No tab context available' } };\n  }\n\n  try {\n    // Use browser-compatible API\n    const tabsApi = (typeof browser !== 'undefined' ? browser.tabs : chrome.tabs);\n    const dataUrl = await tabsApi.captureVisibleTab({ format: 'png' });\n    return { id: ctx.id, ok: true, result: { dataUrl } };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Screenshot failed' },\n    };\n  }\n}\n\n/**\n * Get interactive elements on the page.\n */\nasync function handleBrowserGetElements(ctx: RequestContext): HandlerResponse {\n  if (!await hasPermission(ctx.origin, 'browser:activeTab.read')) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Permission browser:activeTab.read required' },\n    };\n  }\n\n  if (!ctx.tabId) {\n    return { id: ctx.id, ok: false, error: { code: 'ERR_INTERNAL', message: 'No tab context available' } };\n  }\n\n  type ElementInfo = {\n    ref: string;\n    tag: string;\n    type?: string;\n    text?: string;\n    placeholder?: string;\n    value?: string;\n    role?: string;\n  };\n\n  try {\n    const result = await executeScriptInTab<ElementInfo[]>(\n      ctx.tabId,\n      () => {\n        const elements: Array<{\n          ref: string;\n          tag: string;\n          type?: string;\n          text?: string;\n          placeholder?: string;\n          value?: string;\n          role?: string;\n        }> = [];\n\n        // Find interactive elements\n        const selectors = [\n          'a[href]',\n          'button',\n          'input',\n          'select',\n          'textarea',\n          '[role=\"button\"]',\n          '[role=\"link\"]',\n          '[onclick]',\n          '[contenteditable=\"true\"]',\n        ];\n\n        const seen = new Set<Element>();\n        \n        for (const selector of selectors) {\n          for (const el of document.querySelectorAll(selector)) {\n            if (seen.has(el)) continue;\n            seen.add(el);\n\n            // Skip hidden elements\n            const style = window.getComputedStyle(el);\n            if (style.display === 'none' || style.visibility === 'hidden') continue;\n\n            const rect = el.getBoundingClientRect();\n            if (rect.width === 0 || rect.height === 0) continue;\n\n            // Generate a unique ref (prefer id, then create a path)\n            let ref = '';\n            if (el.id) {\n              ref = `#${el.id}`;\n            } else {\n              // Generate a simple CSS path\n              const parts: string[] = [];\n              let current: Element | null = el;\n              while (current && current !== document.body) {\n                let pathSelector = current.tagName.toLowerCase();\n                if (current.id) {\n                  pathSelector = `#${current.id}`;\n                  parts.unshift(pathSelector);\n                  break;\n                }\n                const parent = current.parentElement;\n                if (parent) {\n                  const siblings = Array.from(parent.children).filter(c => c.tagName === current!.tagName);\n                  if (siblings.length > 1) {\n                    const index = siblings.indexOf(current) + 1;\n                    pathSelector += `:nth-of-type(${index})`;\n                  }\n                }\n                parts.unshift(pathSelector);\n                current = parent;\n              }\n              ref = parts.join(' > ');\n            }\n\n            const info: typeof elements[0] = {\n              ref,\n              tag: el.tagName.toLowerCase(),\n            };\n\n            if (el instanceof HTMLInputElement) {\n              info.type = el.type;\n              if (el.placeholder) info.placeholder = el.placeholder;\n              if (el.value && el.type !== 'password') info.value = el.value;\n            } else if (el instanceof HTMLTextAreaElement) {\n              if (el.placeholder) info.placeholder = el.placeholder;\n            } else if (el instanceof HTMLSelectElement) {\n              info.value = el.value;\n            }\n\n            const text = el.textContent?.trim().slice(0, 100);\n            if (text) info.text = text;\n\n            const role = el.getAttribute('role');\n            if (role) info.role = role;\n\n            elements.push(info);\n          }\n        }\n\n        return elements;\n      },\n      []\n    );\n\n    if (!result) {\n      return { id: ctx.id, ok: false, error: { code: 'ERR_INTERNAL', message: 'Script execution failed' } };\n    }\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'GetElements failed' },\n    };\n  }\n}\n\n/**\n * Get page content using readability-like extraction.\n */\nasync function handleBrowserReadability(ctx: RequestContext): HandlerResponse {\n  if (!await hasPermission(ctx.origin, 'browser:activeTab.read')) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Permission browser:activeTab.read required' },\n    };\n  }\n\n  if (!ctx.tabId) {\n    return { id: ctx.id, ok: false, error: { code: 'ERR_INTERNAL', message: 'No tab context available' } };\n  }\n\n  type ReadabilityResult = {\n    title: string;\n    url: string;\n    content: string;\n    length: number;\n  };\n\n  try {\n    const result = await executeScriptInTab<ReadabilityResult>(\n      ctx.tabId,\n      () => {\n        // Simple text extraction (a full readability implementation would be more complex)\n        const title = document.title;\n        const url = window.location.href;\n        \n        // Try to find main content\n        const mainSelectors = ['main', 'article', '[role=\"main\"]', '.content', '#content', '.post', '.article'];\n        let content = '';\n        \n        for (const selector of mainSelectors) {\n          const el = document.querySelector(selector);\n          if (el) {\n            content = el.textContent?.trim() || '';\n            break;\n          }\n        }\n        \n        // Fallback to body text\n        if (!content) {\n          content = document.body.textContent?.trim() || '';\n        }\n        \n        // Clean up whitespace\n        content = content.replace(/\\s+/g, ' ').trim();\n        \n        return {\n          title,\n          url,\n          content: content.slice(0, 50000), // Limit size\n          length: content.length,\n        };\n      },\n      []\n    );\n\n    if (!result) {\n      return { id: ctx.id, ok: false, error: { code: 'ERR_INTERNAL', message: 'Script execution failed' } };\n    }\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Readability extraction failed' },\n    };\n  }\n}\n\n// =============================================================================\n// Tab Management (Extension 2)\n// =============================================================================\n\n/**\n * Create a new tab.\n */\nasync function handleTabsCreate(ctx: RequestContext): HandlerResponse {\n  if (!await hasPermission(ctx.origin, 'browser:tabs.create')) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Permission browser:tabs.create required' },\n    };\n  }\n\n  const payload = ctx.payload as { url: string; active?: boolean; index?: number; windowId?: number };\n  \n  if (!payload.url) {\n    return { id: ctx.id, ok: false, error: { code: 'ERR_INVALID_REQUEST', message: 'Missing url parameter' } };\n  }\n\n  try {\n    const tab = await chrome.tabs.create({\n      url: payload.url,\n      active: payload.active ?? false,\n      index: payload.index,\n      windowId: payload.windowId,\n    });\n\n    if (!tab.id) {\n      return { id: ctx.id, ok: false, error: { code: 'ERR_INTERNAL', message: 'Failed to create tab' } };\n    }\n\n    // Track this tab as spawned by this origin\n    trackSpawnedTab(ctx.origin, tab.id);\n\n    return {\n      id: ctx.id,\n      ok: true,\n      result: {\n        id: tab.id,\n        url: tab.url || payload.url,\n        title: tab.title || '',\n        active: tab.active,\n        index: tab.index,\n        windowId: tab.windowId,\n        canControl: true,\n      },\n    };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Failed to create tab' },\n    };\n  }\n}\n\n/**\n * List all tabs.\n */\nasync function handleTabsList(ctx: RequestContext): HandlerResponse {\n  if (!await hasPermission(ctx.origin, 'browser:tabs.read')) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Permission browser:tabs.read required' },\n    };\n  }\n\n  try {\n    const tabs = await chrome.tabs.query({});\n    const result = tabs.map(tab => ({\n      id: tab.id!,\n      url: tab.url || '',\n      title: tab.title || '',\n      active: tab.active,\n      index: tab.index,\n      windowId: tab.windowId,\n      favIconUrl: tab.favIconUrl,\n      status: tab.status as 'loading' | 'complete' | undefined,\n      canControl: tab.id ? isSpawnedTab(ctx.origin, tab.id) : false,\n    }));\n\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Failed to list tabs' },\n    };\n  }\n}\n\n/**\n * Close a tab that this origin created.\n */\nasync function handleTabsClose(ctx: RequestContext): HandlerResponse {\n  if (!await hasPermission(ctx.origin, 'browser:tabs.create')) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Permission browser:tabs.create required' },\n    };\n  }\n\n  const { tabId } = ctx.payload as { tabId: number };\n  \n  if (typeof tabId !== 'number') {\n    return { id: ctx.id, ok: false, error: { code: 'ERR_INVALID_REQUEST', message: 'Missing tabId parameter' } };\n  }\n\n  // Only allow closing tabs that this origin created\n  if (!isSpawnedTab(ctx.origin, tabId)) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Can only close tabs created by this origin' },\n    };\n  }\n\n  try {\n    await chrome.tabs.remove(tabId);\n    untrackSpawnedTab(ctx.origin, tabId);\n    return { id: ctx.id, ok: true, result: true };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Failed to close tab' },\n    };\n  }\n}\n\n/**\n * Get readability content from a spawned tab.\n */\nasync function handleSpawnedTabReadability(ctx: RequestContext): HandlerResponse {\n  if (!await hasPermission(ctx.origin, 'browser:tabs.create')) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Permission browser:tabs.create required' },\n    };\n  }\n\n  const { tabId } = ctx.payload as { tabId: number };\n  \n  if (typeof tabId !== 'number') {\n    return { id: ctx.id, ok: false, error: { code: 'ERR_INVALID_REQUEST', message: 'Missing tabId parameter' } };\n  }\n\n  // Only allow reading from tabs that this origin created\n  if (!isSpawnedTab(ctx.origin, tabId)) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Can only read from tabs created by this origin' },\n    };\n  }\n\n  type ReadabilityResult = {\n    title: string;\n    url: string;\n    content: string;\n    text: string;\n    length: number;\n  };\n\n  try {\n    const result = await executeScriptInTab<ReadabilityResult>(\n      tabId,\n      () => {\n        const title = document.title;\n        const url = window.location.href;\n        \n        // Try to find main content\n        const mainSelectors = ['main', 'article', '[role=\"main\"]', '.content', '#content', '.post', '.article'];\n        let content = '';\n        \n        for (const selector of mainSelectors) {\n          const el = document.querySelector(selector);\n          if (el) {\n            content = el.textContent?.trim() || '';\n            break;\n          }\n        }\n        \n        // Fallback to body text\n        if (!content) {\n          content = document.body.textContent?.trim() || '';\n        }\n        \n        // Clean up whitespace\n        content = content.replace(/\\s+/g, ' ').trim();\n        \n        return {\n          title,\n          url,\n          content: content.slice(0, 50000),\n          text: content.slice(0, 50000), // Alias for compatibility\n          length: content.length,\n        };\n      },\n      []\n    );\n\n    if (!result) {\n      return { id: ctx.id, ok: false, error: { code: 'ERR_INTERNAL', message: 'Script execution failed' } };\n    }\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Readability extraction failed' },\n    };\n  }\n}\n\n/**\n * Get HTML content from a spawned tab.\n */\nasync function handleSpawnedTabGetHtml(ctx: RequestContext): HandlerResponse {\n  if (!await hasPermission(ctx.origin, 'browser:tabs.create')) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Permission browser:tabs.create required' },\n    };\n  }\n\n  const { tabId, selector } = ctx.payload as { tabId: number; selector?: string };\n  \n  if (typeof tabId !== 'number') {\n    return { id: ctx.id, ok: false, error: { code: 'ERR_INVALID_REQUEST', message: 'Missing tabId parameter' } };\n  }\n\n  // Only allow reading from tabs that this origin created\n  if (!isSpawnedTab(ctx.origin, tabId)) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Can only read from tabs created by this origin' },\n    };\n  }\n\n  try {\n    const result = await executeScriptInTab<{ html: string; url: string; title: string }>(\n      tabId,\n      (containerSelector: string | null) => {\n        const container = containerSelector \n          ? document.querySelector(containerSelector) \n          : document.body;\n        \n        return {\n          html: container?.outerHTML || document.body.outerHTML,\n          url: window.location.href,\n          title: document.title,\n        };\n      },\n      [selector || null]\n    );\n\n    if (!result) {\n      return { id: ctx.id, ok: false, error: { code: 'ERR_INTERNAL', message: 'Script execution failed' } };\n    }\n    return { id: ctx.id, ok: true, result };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Get HTML failed' },\n    };\n  }\n}\n\n/**\n * Wait for a spawned tab to finish loading.\n */\nasync function handleSpawnedTabWaitForLoad(ctx: RequestContext): HandlerResponse {\n  if (!await hasPermission(ctx.origin, 'browser:tabs.create')) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Permission browser:tabs.create required' },\n    };\n  }\n\n  const { tabId, timeout = 30000 } = ctx.payload as { tabId: number; timeout?: number };\n  \n  if (typeof tabId !== 'number') {\n    return { id: ctx.id, ok: false, error: { code: 'ERR_INVALID_REQUEST', message: 'Missing tabId parameter' } };\n  }\n\n  // Only allow waiting for tabs that this origin created\n  if (!isSpawnedTab(ctx.origin, tabId)) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_PERMISSION_DENIED', message: 'Can only wait for tabs created by this origin' },\n    };\n  }\n\n  try {\n    // Check if tab is already complete\n    const tab = await chrome.tabs.get(tabId);\n    if (tab.status === 'complete') {\n      return { id: ctx.id, ok: true, result: undefined };\n    }\n\n    // Wait for the tab to finish loading\n    await new Promise<void>((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        chrome.tabs.onUpdated.removeListener(listener);\n        reject(new Error('Navigation timeout'));\n      }, timeout);\n\n      const listener = (\n        updatedTabId: number,\n        changeInfo: chrome.tabs.TabChangeInfo,\n      ) => {\n        if (updatedTabId === tabId && changeInfo.status === 'complete') {\n          clearTimeout(timeoutId);\n          chrome.tabs.onUpdated.removeListener(listener);\n          resolve();\n        }\n      };\n\n      chrome.tabs.onUpdated.addListener(listener);\n    });\n\n    return { id: ctx.id, ok: true, result: undefined };\n  } catch (e) {\n    return {\n      id: ctx.id,\n      ok: false,\n      error: { code: 'ERR_INTERNAL', message: e instanceof Error ? e.message : 'Wait for load failed' },\n    };\n  }\n}\n\n// =============================================================================\n// Message Router\n// =============================================================================\n\nasync function routeMessage(ctx: RequestContext): HandlerResponse {\n  switch (ctx.type) {\n    // AI operations\n    case 'ai.canCreateTextSession':\n      return handleAiCanCreateTextSession(ctx);\n    case 'ai.createTextSession':\n    case 'ai.languageModel.create':\n      return handleAiCreateTextSession(ctx);\n    case 'session.prompt':\n      return handleSessionPrompt(ctx);\n    case 'session.destroy':\n      return handleSessionDestroy(ctx);\n    case 'ai.languageModel.capabilities':\n      return handleLanguageModelCapabilities(ctx);\n    case 'ai.providers.list':\n      return handleProviderslist(ctx);\n    case 'ai.providers.getActive':\n      return handleProvidersGetActive(ctx);\n\n    // Permission operations\n    case 'agent.requestPermissions':\n      return handleRequestPermissions(ctx);\n    case 'agent.permissions.list':\n      return handlePermissionsList(ctx);\n\n    // Tool operations\n    case 'agent.tools.list':\n      return handleToolsList(ctx);\n    case 'agent.tools.call':\n      return handleToolsCall(ctx);\n\n    // Session operations (explicit sessions)\n    case 'agent.sessions.create':\n      return handleSessionsCreate(ctx);\n    case 'agent.sessions.get':\n      return handleSessionsGet(ctx);\n    case 'agent.sessions.list':\n      return handleSessionsList(ctx);\n    case 'agent.sessions.terminate':\n      return handleSessionsTerminate(ctx);\n\n    // MCP server operations\n    case 'agent.mcp.discover':\n      return handleMcpDiscover(ctx);\n    case 'agent.mcp.register':\n      return handleMcpRegister(ctx);\n    case 'agent.mcp.unregister':\n      return handleMcpUnregister(ctx);\n\n    // Chat API operations\n    case 'agent.chat.canOpen':\n      return handleChatCanOpen(ctx);\n    case 'agent.chat.open':\n      return handleChatOpen(ctx);\n    case 'agent.chat.close':\n      return handleChatClose(ctx);\n\n    // Browser interaction operations\n    case 'agent.browser.activeTab.click':\n      return handleBrowserClick(ctx);\n    case 'agent.browser.activeTab.fill':\n      return handleBrowserFill(ctx);\n    case 'agent.browser.activeTab.scroll':\n      return handleBrowserScroll(ctx);\n    case 'agent.browser.activeTab.screenshot':\n      return handleBrowserScreenshot(ctx);\n    case 'agent.browser.activeTab.getElements':\n      return handleBrowserGetElements(ctx);\n    case 'agent.browser.activeTab.readability':\n      return handleBrowserReadability(ctx);\n    case 'agent.browser.activeTab.select':\n      return handleBrowserSelect(ctx);\n\n    // Tab management operations\n    case 'agent.browser.tabs.create':\n      return handleTabsCreate(ctx);\n    case 'agent.browser.tabs.list':\n      return handleTabsList(ctx);\n    case 'agent.browser.tabs.close':\n      return handleTabsClose(ctx);\n\n    // Spawned tab operations\n    case 'agent.browser.tab.readability':\n      return handleSpawnedTabReadability(ctx);\n    case 'agent.browser.tab.getHtml':\n      return handleSpawnedTabGetHtml(ctx);\n    case 'agent.browser.tab.waitForLoad':\n      return handleSpawnedTabWaitForLoad(ctx);\n\n    // Multi-agent operations\n    case 'agent.agents.register':\n      return handleAgentsRegister(ctx);\n    case 'agent.agents.unregister':\n      return handleAgentsUnregister(ctx);\n    case 'agent.agents.getInfo':\n      return handleAgentsGetInfo(ctx);\n    case 'agent.agents.discover':\n      return handleAgentsDiscover(ctx);\n    case 'agent.agents.list':\n      return handleAgentsList(ctx);\n    case 'agent.agents.invoke':\n      return handleAgentsInvoke(ctx);\n    case 'agent.agents.send':\n      return handleAgentsSend(ctx);\n    case 'agent.agents.subscribe':\n      return handleAgentsSubscribe(ctx);\n    case 'agent.agents.unsubscribe':\n      return handleAgentsUnsubscribe(ctx);\n    case 'agent.agents.broadcast':\n      return handleAgentsBroadcast(ctx);\n    case 'agent.agents.orchestrate.pipeline':\n      return handleAgentsPipeline(ctx);\n    case 'agent.agents.orchestrate.parallel':\n      return handleAgentsParallel(ctx);\n    case 'agent.agents.orchestrate.route':\n      return handleAgentsRoute(ctx);\n\n    default:\n      return {\n        id: ctx.id,\n        ok: false,\n        error: { code: 'ERR_INTERNAL', message: `Unknown message type: ${ctx.type}` },\n      };\n  }\n}\n\n// =============================================================================\n// Port Connection Handler\n// =============================================================================\n\nchrome.runtime.onConnect.addListener((port) => {\n  if (port.name !== 'web-agent-transport') return;\n  \n  console.log('[Web Agents API] Port connected, sender:', JSON.stringify(port.sender));\n\n  port.onMessage.addListener(async (message: RequestContext & { type: string }) => {\n    const tabId = port.sender?.tab?.id;\n    console.log('[Web Agents API] Port message received:', message.type, 'tabId:', tabId);\n    \n    const ctx: RequestContext = {\n      id: message.id,\n      type: message.type,\n      payload: message.payload,\n      origin: message.origin || '',\n      tabId,\n    };\n\n    // Handle streaming requests\n    if (ctx.type === 'session.promptStreaming') {\n      const sendEvent = (event: TransportStreamEvent) => {\n        try {\n          port.postMessage(event);\n        } catch {\n          // Port disconnected\n        }\n      };\n      await handleSessionPromptStreaming(ctx, sendEvent);\n      return;\n    }\n\n    // Handle agent.run (agentic loop)\n    if (ctx.type === 'agent.run') {\n      const sendEvent = (event: TransportStreamEvent) => {\n        try {\n          port.postMessage(event);\n        } catch {\n          // Port disconnected\n        }\n      };\n      await handleAgentRun(ctx, sendEvent);\n      return;\n    }\n\n    // Handle regular requests\n    const response = await routeMessage(ctx);\n    try {\n      port.postMessage(response);\n    } catch {\n      // Port disconnected\n    }\n  });\n});\n\n// =============================================================================\n// Harbor Discovery Handler\n// =============================================================================\n\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  if (message?.type === 'harbor_discovered' && message.extensionId) {\n    setHarborExtensionId(message.extensionId);\n    sendResponse({ ok: true });\n  }\n  return false;\n});\n\n// =============================================================================\n// Agent Invocation Response Handler\n// =============================================================================\n\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n  if (message?.type !== 'agentInvocationResponse') {\n    return false;\n  }\n  \n  const { invocationId, success, result, error } = message.response as {\n    invocationId: string;\n    success: boolean;\n    result?: unknown;\n    error?: { code: string; message: string };\n  };\n  \n  console.log('[Web Agents API] Received invocation response:', invocationId, success);\n  \n  const pending = pendingInvocations.get(invocationId);\n  if (pending) {\n    pending.resolve({ success, result, error });\n  }\n  \n  sendResponse({ ok: true });\n  return true;\n});\n\n// =============================================================================\n// Harbor Forwarded Invocation Handler\n// =============================================================================\n\n// Track which forwarded invocations we've already processed (to prevent duplicates from multiple listeners)\nconst processedForwardedInvocations = new Set<string>();\n\n// Common handler for forwarded invocations\nfunction handleForwardedInvocation(\n  message: { agentId: string; request: { from: string; task: string; input?: unknown; timeout?: number }; handlerInfo: { origin: string; tabId?: number }; traceId?: string },\n  sendResponse: (response: unknown) => void,\n  source: string\n): boolean {\n  const { agentId, request, handlerInfo, traceId } = message;\n  const trace = traceId || 'no-trace';\n  \n  console.log(`[TRACE ${trace}] handleForwardedInvocation START - source: ${source}, agentId: ${agentId}, task: ${request.task}`);\n  \n  // Create a unique key for this invocation to deduplicate\n  const invocationKey = `${agentId}-${request.from}-${request.task}-${JSON.stringify(request.input || {}).slice(0, 100)}`;\n  \n  if (processedForwardedInvocations.has(invocationKey)) {\n    console.log(`[TRACE ${trace}] DUPLICATE forwarded invocation, skipping - source: ${source}`);\n    // Don't send response - let the other handler do it\n    return false;\n  }\n  processedForwardedInvocations.add(invocationKey);\n  \n  // Clean up after 30 seconds\n  setTimeout(() => processedForwardedInvocations.delete(invocationKey), 30000);\n  \n  // Find the tab to forward to\n  const tabId = handlerInfo.tabId || agentInvocationTabs.get(agentId);\n  console.log(`[TRACE ${trace}] Tab lookup - handlerInfo.tabId: ${handlerInfo.tabId}, agentInvocationTabs: ${agentInvocationTabs.get(agentId)}, final: ${tabId}`);\n  \n  if (!tabId) {\n    console.log(`[TRACE ${trace}] ERROR - no tab found`);\n    sendResponse({ success: false, error: { code: 'ERR_NO_TAB', message: 'Agent tab not found' } });\n    return true;\n  }\n  \n  console.log(`[TRACE ${trace}] Calling handleIncomingInvocation...`);\n  \n  // Forward to tab and wait for response\n  handleIncomingInvocation(agentId, request, trace).then((response) => {\n    console.log(`[TRACE ${trace}] handleIncomingInvocation complete, success: ${response.success}`);\n    sendResponse(response);\n  }).catch((error) => {\n    console.log(`[TRACE ${trace}] handleIncomingInvocation ERROR: ${error.message}`);\n    sendResponse({ success: false, error: { code: 'ERR_FAILED', message: error.message } });\n  });\n  \n  return true; // Async response\n}\n\n// Handle invocation requests forwarded from Harbor via onMessageExternal\nchrome.runtime.onMessageExternal?.addListener((message, _sender, sendResponse) => {\n  if (message?.type !== 'harbor.forwardInvocation') {\n    return false;\n  }\n  return handleForwardedInvocation(message, sendResponse, 'onMessageExternal');\n});\n\n// Also handle via regular onMessage for Firefox compatibility\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  if (message?.type !== 'harbor.forwardInvocation') {\n    return false;\n  }\n  \n  // Check if from another extension (not from ourselves)\n  if (sender.id === chrome.runtime.id) {\n    return false;\n  }\n  \n  return handleForwardedInvocation(message, sendResponse, 'onMessage');\n});\n\n// =============================================================================\n// Sidebar Message Handlers\n// =============================================================================\n\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  // Check Harbor connection status\n  if (message?.type === 'checkHarborConnection') {\n    (async () => {\n      const state = getHarborState();\n      if (!state.connected) {\n        // Try to discover Harbor\n        const id = await discoverHarbor();\n        sendResponse({ connected: !!id, extensionId: id });\n      } else {\n        sendResponse({ connected: true, extensionId: state.extensionId });\n      }\n    })();\n    return true;\n  }\n\n  // Get permissions for a specific origin\n  if (message?.type === 'getPermissionsForOrigin') {\n    const { origin } = message as { origin?: string };\n    if (!origin) {\n      sendResponse({ scopes: {}, allowedTools: [] });\n      return true;\n    }\n\n    (async () => {\n      const permissions = await getPermissions(origin);\n      const scopes: Record<string, string> = {};\n      \n      for (const [scope, grant] of Object.entries(permissions.scopes || {})) {\n        if (grant.type === 'granted-once' && grant.expiresAt && Date.now() > grant.expiresAt) {\n          scopes[scope] = 'not-granted';\n        } else {\n          scopes[scope] = grant.type;\n        }\n      }\n\n      sendResponse({ scopes, allowedTools: permissions.allowedTools || [] });\n    })();\n    return true;\n  }\n\n  // List all permissions\n  if (message?.type === 'listAllPermissions') {\n    (async () => {\n      const permissions = await listAllPermissions();\n      sendResponse({ permissions });\n    })();\n    return true;\n  }\n\n  // Revoke permissions for an origin\n  if (message?.type === 'revokePermissions') {\n    const { origin } = message as { origin?: string };\n    if (!origin) {\n      sendResponse({ ok: false, error: 'Missing origin' });\n      return true;\n    }\n\n    (async () => {\n      await revokeOriginPermissions(origin);\n      sendResponse({ ok: true });\n    })();\n    return true;\n  }\n\n  // Revoke all permissions\n  if (message?.type === 'revokeAllPermissions') {\n    (async () => {\n      const result = await chrome.storage.local.get(null);\n      const keysToRemove: string[] = [];\n      \n      for (const key of Object.keys(result)) {\n        if (key.startsWith('permissions:')) {\n          keysToRemove.push(key);\n        }\n      }\n      \n      if (keysToRemove.length > 0) {\n        await chrome.storage.local.remove(keysToRemove);\n      }\n      \n      sendResponse({ ok: true });\n    })();\n    return true;\n  }\n\n  // Get feature flags for content script injection\n  if (message?.type === 'getFeatureFlags') {\n    (async () => {\n      const flags = await getFeatureFlags();\n      sendResponse(flags);\n    })();\n    return true;\n  }\n\n  return false;\n});\n\n// =============================================================================\n// Initialization\n// =============================================================================\n\n// Try to discover Harbor on startup\ndiscoverHarbor().then((id) => {\n  if (id) {\n    console.log('[Web Agents API] Harbor found:', id);\n  } else {\n    console.log('[Web Agents API] Harbor not found - will retry on first request');\n  }\n});\n\nconsole.log('[Web Agents API] Extension initialized.');\n"],
  "mappings": "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",
  "names": ["event"]
}
