{
  "version": 3,
  "sources": ["../src/content-script.ts"],
  "sourcesContent": ["/**\n * Web Agents API - Content Script\n *\n * Bridges messages between:\n * - Injected script (web page context)\n * - Background script (extension context)\n */\n\nimport type {\n  TransportRequest,\n  TransportResponse,\n  TransportStreamEvent,\n} from './types';\n\nconst CHANNEL = 'web_agents_api';\n\ntype RuntimePort = chrome.runtime.Port;\n\nlet backgroundPort: RuntimePort | null = null;\n\n// Track pending requests and active streams\nconst pendingRequests = new Map<string, {\n  sendResponse: (response: TransportResponse) => void;\n}>();\n\nconst activeStreams = new Map<string, {\n  sendEvent: (event: TransportStreamEvent) => void;\n}>();\n\n// Track if agent event forwarding is set up\nlet agentEventForwardingSetup = false;\n\n/**\n * Get or create connection to background script.\n */\nfunction getBackgroundPort(): RuntimePort {\n  if (!backgroundPort || !backgroundPort.name) {\n    backgroundPort = chrome.runtime.connect({ name: 'web-agent-transport' });\n\n    // Handle messages from background\n    backgroundPort.onMessage.addListener((message: TransportResponse | TransportStreamEvent) => {\n      if ('ok' in message) {\n        // Regular response\n        const pending = pendingRequests.get(message.id);\n        if (pending) {\n          pendingRequests.delete(message.id);\n          pending.sendResponse(message);\n        }\n      } else if ('event' in message) {\n        // Stream event\n        const stream = activeStreams.get(message.id);\n        if (stream) {\n          stream.sendEvent(message);\n          if (message.done) {\n            activeStreams.delete(message.id);\n          }\n        }\n      }\n    });\n\n    backgroundPort.onDisconnect.addListener(() => {\n      backgroundPort = null;\n      // Reject all pending requests\n      for (const [id, pending] of pendingRequests) {\n        pending.sendResponse({\n          id,\n          ok: false,\n          error: { code: 'ERR_INTERNAL', message: 'Background connection lost' },\n        });\n      }\n      pendingRequests.clear();\n      \n      // End all active streams\n      for (const [id, stream] of activeStreams) {\n        stream.sendEvent({\n          id,\n          event: { type: 'error', error: { code: 'ERR_INTERNAL', message: 'Background connection lost' } },\n          done: true,\n        });\n      }\n      activeStreams.clear();\n    });\n  }\n\n  return backgroundPort;\n}\n\n// Feature flags type\ninterface FeatureFlags {\n  textGeneration: boolean;\n  toolCalling: boolean;\n  toolAccess: boolean;\n  browserInteraction: boolean;\n  browserControl: boolean;\n  multiAgent: boolean;\n}\n\nconst DEFAULT_FLAGS: FeatureFlags = {\n  textGeneration: true,\n  toolCalling: false,\n  toolAccess: true,\n  browserInteraction: false,\n  browserControl: false,\n  multiAgent: false,\n};\n\n/**\n * Fetch feature flags from background script.\n */\nasync function getFeatureFlags(): Promise<FeatureFlags> {\n  return new Promise((resolve) => {\n    chrome.runtime.sendMessage({ type: 'getFeatureFlags' }, (response) => {\n      if (chrome.runtime.lastError || !response) {\n        // Default to safe mode if we can't get flags\n        resolve(DEFAULT_FLAGS);\n      } else {\n        resolve(response as FeatureFlags);\n      }\n    });\n  });\n}\n\nlet injected = false;\n\nfunction appendInjectedScripts(flags: FeatureFlags): boolean {\n  if (injected) return true;\n  const root = document.head || document.documentElement;\n  if (!root) return false;\n\n  // First, inject the feature flags as a JSON element\n  const flagsScript = document.createElement('script');\n  flagsScript.type = 'application/json';\n  flagsScript.id = 'web-agents-api-flags';\n  flagsScript.textContent = JSON.stringify(flags);\n  root.appendChild(flagsScript);\n\n  // Then inject the main script\n  const script = document.createElement('script');\n  script.src = chrome.runtime.getURL('injected.js');\n  script.async = false;\n  script.onload = () => {\n    script.remove();\n  };\n  script.onerror = () => {\n    script.remove();\n  };\n  root.appendChild(script);\n  injected = true;\n  return true;\n}\n\n/**\n * Inject the Web Agents API script into the page with feature flags.\n */\nasync function injectAgentsAPI(): Promise<void> {\n  // Mark content script presence for debugging.\n  document.documentElement?.setAttribute('data-web-agents-content-script', 'true');\n\n  // Wait for Harbor discovery to be available\n  const checkHarbor = () => {\n    const harborInfo = (window as { __harbor?: { extensionId: string } }).__harbor;\n    if (harborInfo?.extensionId) {\n      // Harbor found, notify background\n      chrome.runtime.sendMessage({ \n        type: 'harbor_discovered', \n        extensionId: harborInfo.extensionId \n      });\n    }\n  };\n\n  // Check immediately and also listen for discovery event\n  checkHarbor();\n  window.addEventListener('harbor-discovered', checkHarbor);\n\n  // Get feature flags from background\n  const flags = await getFeatureFlags();\n\n  if (appendInjectedScripts(flags)) return;\n\n  const retry = () => {\n    if (appendInjectedScripts(flags)) {\n      document.removeEventListener('readystatechange', retry);\n      window.removeEventListener('DOMContentLoaded', retry);\n    }\n  };\n\n  document.addEventListener('readystatechange', retry);\n  window.addEventListener('DOMContentLoaded', retry);\n}\n\n/**\n * Listen for messages from the page.\n */\nwindow.addEventListener('message', async (event: MessageEvent) => {\n  if (event.source !== window) return;\n\n  const data = event.data as {\n    channel?: string;\n    request?: TransportRequest;\n    abort?: { id: string };\n  };\n\n  if (data?.channel !== CHANNEL) return;\n\n  // Handle abort signal\n  if (data.abort) {\n    const port = getBackgroundPort();\n    port.postMessage({ type: 'abort', id: data.abort.id });\n    activeStreams.delete(data.abort.id);\n    return;\n  }\n\n  if (!data.request) return;\n\n  const request = data.request;\n  const isStreamingRequest = request.type === 'session.promptStreaming' || request.type === 'agent.run';\n\n  const port = getBackgroundPort();\n\n  if (isStreamingRequest) {\n    // Set up stream forwarding\n    activeStreams.set(request.id, {\n      sendEvent: (streamEvent) => {\n        window.postMessage({ channel: CHANNEL, streamEvent }, '*');\n      },\n    });\n  } else {\n    // Set up response forwarding\n    pendingRequests.set(request.id, {\n      sendResponse: (response) => {\n        window.postMessage({ channel: CHANNEL, response }, '*');\n      },\n    });\n  }\n\n  // Forward to background with origin\n  port.postMessage({\n    ...request,\n    origin: window.location.origin,\n  });\n});\n\n/**\n * Set up forwarding of agent events from background to the page.\n * This enables the multi-agent messaging system.\n */\nfunction setupAgentEventForwarding() {\n  if (agentEventForwardingSetup) return;\n  agentEventForwardingSetup = true;\n\n  // Listen for agent events from background\n  chrome.runtime.onMessage.addListener((message) => {\n    if (message?.type === 'agentEvent') {\n      // Forward to the page\n      window.postMessage({\n        channel: CHANNEL,\n        agentEvent: message.event,\n      }, '*');\n    }\n    return false;\n  });\n}\n\n// Listen for agent invocation responses from the page\nwindow.addEventListener('message', (event: MessageEvent) => {\n  if (event.source !== window) return;\n\n  const data = event.data as {\n    channel?: string;\n    agentInvocationResponse?: {\n      invocationId: string;\n      success: boolean;\n      result?: unknown;\n      error?: { code: string; message: string };\n    };\n  };\n\n  if (data?.channel !== CHANNEL || !data.agentInvocationResponse) return;\n\n  // Forward to background\n  chrome.runtime.sendMessage({\n    type: 'agentInvocationResponse',\n    response: data.agentInvocationResponse,\n  });\n});\n\n// Track processed invocations to prevent duplicates\nconst processedInvocations = new Set<string>();\n\n// Listen for invocation requests from background and forward to page\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n  if (message?.type !== 'agentInvocation') {\n    return false;\n  }\n  \n  const trace = message.traceId || 'no-trace';\n  \n  // Deduplicate - only process each invocation once\n  const invocationId = message.invocationId;\n  if (processedInvocations.has(invocationId)) {\n    console.log(`[TRACE ${trace}] Content: DUPLICATE invocation, skipping: ${invocationId}`);\n    sendResponse({ ok: true, duplicate: true });\n    return true;\n  }\n  processedInvocations.add(invocationId);\n  \n  // Clean up old invocations after 60 seconds\n  setTimeout(() => processedInvocations.delete(invocationId), 60000);\n  \n  console.log(`[TRACE ${trace}] Content: Forwarding invocation to page - task: ${message.task}, invocationId: ${invocationId}`);\n  \n  // Forward to page in the format injected.ts expects\n  window.postMessage({\n    channel: CHANNEL,\n    agentEvent: {\n      type: 'invocation',\n      invocation: {\n        invocationId: message.invocationId,\n        from: message.from,\n        task: message.task,\n        input: message.input,\n      },\n    },\n  }, '*');\n  \n  sendResponse({ ok: true });\n  return true;\n});\n\n// Track pending Harbor invocations waiting for page response\nconst pendingHarborInvocations = new Map<string, (response: unknown) => void>();\n\n// Listen for invocation responses from the page\nwindow.addEventListener('message', (event) => {\n  if (event.source !== window) return;\n  const data = event.data;\n  if (!data || data.channel !== CHANNEL) return;\n  \n  // Handle invocation response from page (used by both internal and Harbor invocations)\n  if (data.agentInvocationResponse) {\n    const { invocationId, success, result, error } = data.agentInvocationResponse;\n    const resolver = pendingHarborInvocations.get(invocationId);\n    if (resolver) {\n      pendingHarborInvocations.delete(invocationId);\n      // Format response for Harbor\n      resolver({ success, result, error });\n    }\n  }\n});\n\n// Listen for Harbor's forwarded invocations (sent directly to tab)\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n  if (message?.type !== 'harbor.forwardInvocation') {\n    return false;\n  }\n  \n  const trace = message.traceId || 'no-trace';\n  const { agentId, request } = message;\n  const invocationId = `harbor-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n  \n  console.log(`[TRACE ${trace}] Content: Harbor forward invocation - agentId: ${agentId}, task: ${request?.task}`);\n  \n  // Store the sendResponse callback for when the page responds\n  pendingHarborInvocations.set(invocationId, (response) => {\n    console.log(`[TRACE ${trace}] Content: Sending response back to Harbor`);\n    sendResponse(response);\n  });\n  \n  // Forward to page\n  window.postMessage({\n    channel: CHANNEL,\n    agentEvent: {\n      type: 'invocation',\n      invocation: {\n        invocationId,\n        from: request?.from,\n        task: request?.task,\n        input: request?.input,\n      },\n    },\n  }, '*');\n  \n  // Keep channel open for async response\n  return true;\n});\n\n// Initialize\ninjectAgentsAPI().catch(console.error);\nsetupAgentEventForwarding();"],
  "mappings": "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",
  "names": ["port"]
}
