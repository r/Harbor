{
  "version": 3,
  "sources": ["../src/injected.ts"],
  "sourcesContent": ["/**\n * Web Agents API - Injected Script\n *\n * This script is injected into web pages to expose:\n * - window.ai - Text generation API (Chrome Prompt API compatible)\n * - window.agent - Tools, browser access, and tool calling capabilities\n *\n * APIs are gated by feature flags configured in the Web Agents API sidebar.\n */\n\n// Make this a module to avoid global scope conflicts\nexport {};\n\n// =============================================================================\n// Feature Flags\n// =============================================================================\n\ninterface FeatureFlags {\n  textGeneration: boolean;\n  toolCalling: boolean;\n  toolAccess: boolean;\n  browserInteraction: boolean;\n  browserControl: boolean;\n  multiAgent: boolean;\n}\n\n// Read feature flags from injected JSON element\nfunction getFeatureFlags(): FeatureFlags {\n  const defaults: FeatureFlags = {\n    textGeneration: true,\n    toolCalling: false,\n    toolAccess: true,\n    browserInteraction: false,\n    browserControl: false,\n    multiAgent: false,\n  };\n\n  try {\n    const flagsElement = document.getElementById('web-agents-api-flags');\n    if (flagsElement?.textContent) {\n      const parsed = JSON.parse(flagsElement.textContent) as Partial<FeatureFlags>;\n      return { ...defaults, ...parsed };\n    }\n  } catch {\n    // Ignore parse errors, use defaults\n  }\n\n  return defaults;\n}\n\nconst FEATURE_FLAGS = getFeatureFlags();\n\n/**\n * Create a function that throws ERR_FEATURE_DISABLED for disabled features.\n */\nfunction featureDisabled(featureName: string): () => never {\n  return () => {\n    const err = new Error(`Feature \"${featureName}\" is not enabled. Enable it in Web Agents API settings.`);\n    (err as Error & { code?: string }).code = 'ERR_FEATURE_DISABLED';\n    throw err;\n  };\n}\n\n/**\n * Create an async function that rejects with ERR_FEATURE_DISABLED for disabled features.\n */\nfunction featureDisabledAsync(featureName: string): () => Promise<never> {\n  return async () => {\n    const err = new Error(`Feature \"${featureName}\" is not enabled. Enable it in Web Agents API settings.`);\n    (err as Error & { code?: string }).code = 'ERR_FEATURE_DISABLED';\n    throw err;\n  };\n}\n\n// =============================================================================\n// Types\n// =============================================================================\n\ntype PermissionScope =\n  | 'model:prompt'\n  | 'model:tools'\n  | 'model:list'\n  | 'mcp:tools.list'\n  | 'mcp:tools.call'\n  | 'mcp:servers.register'\n  | 'browser:activeTab.read'\n  | 'browser:activeTab.interact'\n  | 'browser:activeTab.screenshot'\n  | 'chat:open'\n  | 'web:fetch';\n\ntype PermissionGrant = 'granted-once' | 'granted-always' | 'denied' | 'not-granted';\n\ninterface PermissionGrantResult {\n  granted: boolean;\n  scopes: Record<PermissionScope, PermissionGrant>;\n  allowedTools?: string[];\n}\n\ninterface PermissionStatus {\n  origin: string;\n  scopes: Record<PermissionScope, PermissionGrant>;\n  allowedTools?: string[];\n}\n\ninterface TextSessionOptions {\n  model?: string;\n  provider?: string;\n  temperature?: number;\n  systemPrompt?: string;\n}\n\ninterface StreamToken {\n  type: 'token' | 'done' | 'error';\n  token?: string;\n  error?: { code: string; message: string };\n}\n\ninterface LLMProviderInfo {\n  id: string;\n  type: string;\n  name: string;\n  available: boolean;\n  models?: string[];\n  isDefault: boolean;\n}\n\ninterface ToolDescriptor {\n  name: string;\n  description?: string;\n  inputSchema?: Record<string, unknown>;\n  serverId?: string;\n}\n\n// Session types\ninterface SessionCapabilities {\n  llm: { allowed: boolean; provider?: string; model?: string };\n  tools: { allowed: boolean; allowedTools: string[] };\n  browser: { readActiveTab: boolean; interact: boolean; screenshot: boolean };\n  limits?: { maxToolCalls?: number; expiresAt?: number };\n}\n\ninterface SessionUsage {\n  promptCount: number;\n  toolCallCount: number;\n}\n\ninterface SessionSummary {\n  sessionId: string;\n  type: 'implicit' | 'explicit';\n  origin: string;\n  status: 'active' | 'suspended' | 'terminated';\n  name?: string;\n  createdAt: number;\n  lastActiveAt: number;\n  capabilities: {\n    hasLLM: boolean;\n    toolCount: number;\n    hasBrowserAccess: boolean;\n  };\n  usage: SessionUsage;\n}\n\ninterface CreateSessionOptions {\n  name?: string;\n  reason?: string;\n  capabilities: {\n    llm?: { provider?: string; model?: string };\n    tools?: string[];\n    browser?: ('read' | 'interact' | 'screenshot')[];\n  };\n  limits?: {\n    maxToolCalls?: number;\n    ttlMinutes?: number;\n  };\n  options?: {\n    systemPrompt?: string;\n    temperature?: number;\n  };\n}\n\ninterface CreateSessionResult {\n  success: boolean;\n  sessionId?: string;\n  capabilities?: SessionCapabilities;\n  error?: { code: string; message: string };\n}\n\n// =============================================================================\n// Transport Layer\n// =============================================================================\n\nconst CHANNEL = 'web_agents_api';\n\ninterface TransportResponse {\n  id: string;\n  ok: boolean;\n  result?: unknown;\n  error?: { code: string; message: string };\n}\n\ninterface TransportStreamEvent {\n  id: string;\n  event: StreamToken;\n  done?: boolean;\n}\n\nconst pendingRequests = new Map<\n  string,\n  {\n    resolve: (value: unknown) => void;\n    reject: (error: Error) => void;\n  }\n>();\n\nconst streamListeners = new Map<string, (event: StreamToken, done: boolean) => void>();\n\n// Initialize transport\nwindow.addEventListener('message', (event: MessageEvent) => {\n  if (event.source !== window) return;\n\n  const data = event.data as {\n    channel?: string;\n    response?: TransportResponse;\n    streamEvent?: TransportStreamEvent;\n  };\n\n  if (data?.channel !== CHANNEL) return;\n\n  // Handle regular response\n  if (data.response) {\n    const pending = pendingRequests.get(data.response.id);\n    if (pending) {\n      pendingRequests.delete(data.response.id);\n      if (data.response.ok) {\n        pending.resolve(data.response.result);\n      } else {\n        const err = new Error(data.response.error?.message || 'Request failed');\n        (err as Error & { code?: string }).code = data.response.error?.code;\n        pending.reject(err);\n      }\n    }\n  }\n\n  // Handle stream event\n  if (data.streamEvent) {\n    const listener = streamListeners.get(data.streamEvent.id);\n    if (listener) {\n      listener(data.streamEvent.event, data.streamEvent.done || false);\n      if (data.streamEvent.done) {\n        streamListeners.delete(data.streamEvent.id);\n      }\n    }\n  }\n});\n\nfunction sendRequest<T>(type: string, payload?: unknown): Promise<T> {\n  const id = crypto.randomUUID();\n\n  return new Promise((resolve, reject) => {\n    pendingRequests.set(id, {\n      resolve: resolve as (value: unknown) => void,\n      reject,\n    });\n\n    window.postMessage({ channel: CHANNEL, request: { id, type, payload } }, '*');\n\n    // Timeout after 30 seconds\n    setTimeout(() => {\n      if (pendingRequests.has(id)) {\n        pendingRequests.delete(id);\n        const err = new Error('Request timeout');\n        (err as Error & { code?: string }).code = 'ERR_TIMEOUT';\n        reject(err);\n      }\n    }, 30000);\n  });\n}\n\nfunction createStreamIterable<T extends StreamToken>(\n  type: string,\n  payload?: unknown,\n): AsyncIterable<T> {\n  const id = crypto.randomUUID();\n\n  return {\n    [Symbol.asyncIterator](): AsyncIterator<T> {\n      const queue: T[] = [];\n      let resolveNext: ((result: IteratorResult<T>) => void) | null = null;\n      let done = false;\n      let error: Error | null = null;\n\n      // Register stream listener before sending request\n      streamListeners.set(id, (event, isDone) => {\n        if (isDone) {\n          done = true;\n          streamListeners.delete(id);\n        }\n\n        // Check for error event\n        if ('type' in event && event.type === 'error') {\n          error = new Error(event.error?.message || 'Stream error');\n          (error as Error & { code?: string }).code = event.error?.code || 'ERR_INTERNAL';\n          done = true;\n        }\n\n        if (resolveNext && !error) {\n          resolveNext({ done: false, value: event as T });\n          resolveNext = null;\n        } else if (!error) {\n          queue.push(event as T);\n        }\n      });\n\n      // Send the request\n      window.postMessage({ channel: CHANNEL, request: { id, type, payload } }, '*');\n\n      return {\n        async next(): Promise<IteratorResult<T>> {\n          if (error) {\n            throw error;\n          }\n\n          if (queue.length > 0) {\n            return { done: false, value: queue.shift()! };\n          }\n\n          if (done) {\n            return { done: true, value: undefined };\n          }\n\n          return new Promise((resolve) => {\n            resolveNext = resolve;\n          });\n        },\n\n        async return(): Promise<IteratorResult<T>> {\n          done = true;\n          streamListeners.delete(id);\n          // Send abort signal\n          window.postMessage({ channel: CHANNEL, abort: { id } }, '*');\n          return { done: true, value: undefined };\n        },\n      };\n    },\n  };\n}\n\n// =============================================================================\n// TextSession Implementation\n// =============================================================================\n\ninterface TextSession {\n  readonly sessionId: string;\n  prompt(input: string): Promise<string>;\n  promptStreaming(input: string): AsyncIterable<string>;\n  destroy(): void;\n}\n\nfunction createTextSessionObject(sessionId: string): TextSession {\n  return Object.freeze({\n    sessionId,\n\n    async prompt(input: string): Promise<string> {\n      return sendRequest<string>('session.prompt', { sessionId, input });\n    },\n\n    promptStreaming(input: string): AsyncIterable<string> {\n      const tokenIterable = createStreamIterable<StreamToken>('session.promptStreaming', { sessionId, input });\n      \n      // Transform to yield just the token strings\n      return {\n        [Symbol.asyncIterator]() {\n          const tokenIterator = tokenIterable[Symbol.asyncIterator]();\n          \n          return {\n            async next(): Promise<IteratorResult<string>> {\n              const result = await tokenIterator.next();\n              if (result.done) {\n                return { done: true, value: undefined };\n              }\n              if (result.value.type === 'token' && result.value.token) {\n                return { done: false, value: result.value.token };\n              }\n              if (result.value.type === 'done') {\n                return { done: true, value: undefined };\n              }\n              if (result.value.type === 'error') {\n                throw new Error(result.value.error?.message || 'Stream error');\n              }\n              // Continue to next token\n              return this.next();\n            },\n            \n            async return(): Promise<IteratorResult<string>> {\n              await tokenIterator.return?.();\n              return { done: true, value: undefined };\n            },\n          };\n        },\n      };\n    },\n\n    destroy(): void {\n      sendRequest('session.destroy', { sessionId }).catch(() => {});\n    },\n  });\n}\n\n// =============================================================================\n// window.ai Implementation\n// =============================================================================\n\nconst aiApi = Object.freeze({\n  async canCreateTextSession(): Promise<'readily' | 'after-download' | 'no'> {\n    return sendRequest<'readily' | 'after-download' | 'no'>('ai.canCreateTextSession');\n  },\n\n  async createTextSession(options: TextSessionOptions = {}): Promise<TextSession> {\n    const sessionId = await sendRequest<string>('ai.createTextSession', options);\n    return createTextSessionObject(sessionId);\n  },\n\n  languageModel: Object.freeze({\n    async capabilities(): Promise<{\n      available: 'readily' | 'after-download' | 'no';\n      defaultTopK?: number;\n      maxTopK?: number;\n      defaultTemperature?: number;\n    }> {\n      return sendRequest('ai.languageModel.capabilities');\n    },\n\n    async create(options: {\n      systemPrompt?: string;\n      temperature?: number;\n      topK?: number;\n    } = {}): Promise<TextSession> {\n      const sessionOptions: TextSessionOptions = {\n        systemPrompt: options.systemPrompt,\n        temperature: options.temperature,\n      };\n      const sessionId = await sendRequest<string>('ai.languageModel.create', {\n        ...sessionOptions,\n        topK: options.topK,\n      });\n      return createTextSessionObject(sessionId);\n    },\n  }),\n\n  providers: Object.freeze({\n    async list(): Promise<LLMProviderInfo[]> {\n      return sendRequest<LLMProviderInfo[]>('ai.providers.list');\n    },\n\n    async getActive(): Promise<{ provider: string | null; model: string | null }> {\n      return sendRequest('ai.providers.getActive');\n    },\n  }),\n});\n\n// =============================================================================\n// AgentSession Implementation\n// =============================================================================\n\ninterface AgentSession {\n  readonly sessionId: string;\n  readonly capabilities: SessionCapabilities;\n  prompt(input: string): Promise<string>;\n  promptStreaming(input: string): AsyncIterable<string>;\n  callTool(tool: string, args?: Record<string, unknown>): Promise<unknown>;\n  listAllowedTools(): string[];\n  terminate(): Promise<void>;\n}\n\nfunction createAgentSessionObject(\n  sessionId: string,\n  capabilities: SessionCapabilities,\n): AgentSession {\n  return Object.freeze({\n    sessionId,\n    capabilities,\n\n    async prompt(input: string): Promise<string> {\n      if (!capabilities.llm.allowed) {\n        throw new Error('Session does not have LLM access');\n      }\n      return sendRequest<string>('session.prompt', { sessionId, input });\n    },\n\n    promptStreaming(input: string): AsyncIterable<string> {\n      if (!capabilities.llm.allowed) {\n        throw new Error('Session does not have LLM access');\n      }\n      const tokenIterable = createStreamIterable<StreamToken>('session.promptStreaming', { sessionId, input });\n      \n      return {\n        [Symbol.asyncIterator]() {\n          const tokenIterator = tokenIterable[Symbol.asyncIterator]();\n          \n          return {\n            async next(): Promise<IteratorResult<string>> {\n              const result = await tokenIterator.next();\n              if (result.done) {\n                return { done: true, value: undefined };\n              }\n              if (result.value.type === 'token' && result.value.token) {\n                return { done: false, value: result.value.token };\n              }\n              if (result.value.type === 'done') {\n                return { done: true, value: undefined };\n              }\n              if (result.value.type === 'error') {\n                throw new Error(result.value.error?.message || 'Stream error');\n              }\n              return this.next();\n            },\n            \n            async return(): Promise<IteratorResult<string>> {\n              await tokenIterator.return?.();\n              return { done: true, value: undefined };\n            },\n          };\n        },\n      };\n    },\n\n    async callTool(tool: string, args?: Record<string, unknown>): Promise<unknown> {\n      if (!capabilities.tools.allowed) {\n        throw new Error('Session does not have tool access');\n      }\n      if (!capabilities.tools.allowedTools.includes(tool)) {\n        throw new Error(`Tool ${tool} not allowed in this session`);\n      }\n      return sendRequest('agent.tools.call', { tool, args, sessionId });\n    },\n\n    listAllowedTools(): string[] {\n      return capabilities.tools.allowedTools;\n    },\n\n    async terminate(): Promise<void> {\n      await sendRequest('agent.sessions.terminate', { sessionId });\n    },\n  });\n}\n\n// =============================================================================\n// Browser API Implementation\n// =============================================================================\n\n// Browser API types\ninterface ReadabilityContent {\n  title: string;\n  content: string;\n  textContent: string;\n  excerpt: string;\n  byline: string | null;\n  siteName: string | null;\n}\n\ninterface BrowserElement {\n  ref: string;\n  role: string;\n  text?: string;\n  placeholder?: string;\n  value?: string;\n  checked?: boolean;\n  rect?: { x: number; y: number; width: number; height: number };\n}\n\n// Create browser API object\nfunction createBrowserApi() {\n  return Object.freeze({\n    activeTab: Object.freeze({\n      /**\n       * Get readable content from the current page using readability parser.\n       */\n      readability: FEATURE_FLAGS.browserInteraction || FEATURE_FLAGS.browserControl\n        ? async function(): Promise<ReadabilityContent> {\n            return sendRequest<ReadabilityContent>('agent.browser.activeTab.readability');\n          }\n        : featureDisabledAsync('browserInteraction'),\n\n      /**\n       * Get visible interactive elements on the page.\n       */\n      getElements: FEATURE_FLAGS.browserInteraction\n        ? async function(): Promise<BrowserElement[]> {\n            return sendRequest<BrowserElement[]>('agent.browser.activeTab.getElements');\n          }\n        : featureDisabledAsync('browserInteraction'),\n\n      /**\n       * Click an element by ref.\n       */\n      click: FEATURE_FLAGS.browserInteraction\n        ? async function(ref: string): Promise<{ success: boolean }> {\n            return sendRequest('agent.browser.activeTab.click', { ref });\n          }\n        : featureDisabledAsync('browserInteraction'),\n\n      /**\n       * Fill a form field.\n       */\n      fill: FEATURE_FLAGS.browserInteraction\n        ? async function(ref: string, value: string): Promise<{ success: boolean }> {\n            return sendRequest('agent.browser.activeTab.fill', { ref, value });\n          }\n        : featureDisabledAsync('browserInteraction'),\n\n      /**\n       * Scroll the page.\n       */\n      scroll: FEATURE_FLAGS.browserInteraction\n        ? async function(direction: 'up' | 'down' | 'left' | 'right', amount?: number): Promise<{ success: boolean }> {\n            return sendRequest('agent.browser.activeTab.scroll', { direction, amount });\n          }\n        : featureDisabledAsync('browserInteraction'),\n\n      /**\n       * Select an option from a dropdown.\n       */\n      select: FEATURE_FLAGS.browserInteraction\n        ? async function(ref: string, value: string): Promise<{ success: boolean }> {\n            return sendRequest('agent.browser.activeTab.select', { ref, value });\n          }\n        : featureDisabledAsync('browserInteraction'),\n\n      /**\n       * Take a screenshot.\n       */\n      screenshot: FEATURE_FLAGS.browserInteraction\n        ? async function(): Promise<{ dataUrl: string }> {\n            return sendRequest('agent.browser.activeTab.screenshot');\n          }\n        : featureDisabledAsync('browserInteraction'),\n    }),\n\n    /**\n     * Navigate to a URL.\n     */\n    navigate: FEATURE_FLAGS.browserControl\n      ? async function(url: string): Promise<{ success: boolean }> {\n          return sendRequest('agent.browser.navigate', { url });\n        }\n      : featureDisabledAsync('browserControl'),\n\n    /**\n     * Fetch a URL (CORS-bypassing).\n     */\n    fetch: FEATURE_FLAGS.browserControl\n      ? async function(url: string, options?: RequestInit): Promise<{ body: string; status: number; headers: Record<string, string> }> {\n          return sendRequest('agent.browser.fetch', { url, options });\n        }\n      : featureDisabledAsync('browserControl'),\n\n    /**\n     * Tab management (browserControl required).\n     */\n    tabs: FEATURE_FLAGS.browserControl\n      ? Object.freeze({\n          async list(): Promise<Array<{\n            id: number;\n            url: string;\n            title: string;\n            active: boolean;\n            index: number;\n            windowId: number;\n            favIconUrl?: string;\n            status?: 'loading' | 'complete';\n            canControl: boolean;\n          }>> {\n            return sendRequest('agent.browser.tabs.list');\n          },\n          async create(options: {\n            url: string;\n            active?: boolean;\n            index?: number;\n            windowId?: number;\n          }): Promise<{\n            id: number;\n            url: string;\n            title: string;\n            active: boolean;\n            index: number;\n            windowId: number;\n            canControl: boolean;\n          }> {\n            return sendRequest('agent.browser.tabs.create', options);\n          },\n          async close(tabId: number): Promise<boolean> {\n            return sendRequest('agent.browser.tabs.close', { tabId });\n          },\n        })\n      : {\n          list: featureDisabledAsync('browserControl'),\n          create: featureDisabledAsync('browserControl'),\n          close: featureDisabledAsync('browserControl'),\n        },\n\n    /**\n     * Spawned tab operations - for tabs this origin created.\n     */\n    tab: FEATURE_FLAGS.browserControl\n      ? Object.freeze({\n          /**\n           * Extract readable content from a tab this origin created.\n           */\n          async readability(tabId: number): Promise<{\n            title: string;\n            url: string;\n            content: string;\n            text: string;\n            length: number;\n          }> {\n            return sendRequest('agent.browser.tab.readability', { tabId });\n          },\n\n          /**\n           * Get HTML content from a tab this origin created.\n           * @param tabId - The tab ID\n           * @param selector - Optional CSS selector to scope the HTML extraction\n           */\n          async getHtml(tabId: number, selector?: string): Promise<{\n            html: string;\n            url: string;\n            title: string;\n          }> {\n            return sendRequest('agent.browser.tab.getHtml', { tabId, selector });\n          },\n\n          /**\n           * Wait for a tab to finish loading.\n           * @param tabId - The tab ID\n           * @param options - Optional timeout in milliseconds (default 30000)\n           */\n          async waitForLoad(tabId: number, options?: { timeout?: number }): Promise<void> {\n            return sendRequest('agent.browser.tab.waitForLoad', { tabId, ...options });\n          },\n        })\n      : {\n          readability: featureDisabledAsync('browserControl'),\n          getHtml: featureDisabledAsync('browserControl'),\n          waitForLoad: featureDisabledAsync('browserControl'),\n        },\n  });\n}\n\n// =============================================================================\n// Multi-Agent Types (for injected script)\n// =============================================================================\n\ninterface AgentRegisterOptions {\n  name: string;\n  description?: string;\n  capabilities?: string[];\n  tags?: string[];\n  acceptsInvocations?: boolean;\n  acceptsMessages?: boolean;\n}\n\ninterface RegisteredAgent {\n  id: string;\n  name: string;\n  description?: string;\n  capabilities: string[];\n  tags: string[];\n  status: 'active' | 'suspended' | 'terminated';\n  origin: string;\n  acceptsInvocations: boolean;\n  acceptsMessages: boolean;\n  registeredAt: number;\n  lastActiveAt: number;\n}\n\ninterface AgentSummary {\n  id: string;\n  name: string;\n  description?: string;\n  capabilities: string[];\n  tags: string[];\n  status: 'active' | 'suspended' | 'terminated';\n  sameOrigin: boolean;\n  isRemote: boolean;\n}\n\ninterface AgentDiscoveryQuery {\n  name?: string;\n  capabilities?: string[];\n  tags?: string[];\n  includeSameOrigin?: boolean;\n  includeCrossOrigin?: boolean;\n}\n\ninterface AgentInvocationRequest {\n  task: string;\n  input?: unknown;\n  timeout?: number;\n}\n\ninterface AgentInvocationResponse {\n  success: boolean;\n  result?: unknown;\n  error?: { code: string; message: string };\n  executionTime?: number;\n}\n\ninterface AgentMessage {\n  id: string;\n  from: string;\n  to: string;\n  type: 'request' | 'response' | 'event' | 'error';\n  payload: unknown;\n  correlationId?: string;\n  timestamp: number;\n}\n\ninterface PipelineStep {\n  agentId: string;\n  task: string;\n  inputTransform?: string;\n  outputTransform?: string;\n}\n\ninterface ParallelTask {\n  agentId: string;\n  task: string;\n  input?: unknown;\n}\n\n// Store for message and invocation handlers\nconst agentMessageHandlers: Array<(message: AgentMessage) => void> = [];\nconst agentInvocationHandlers: Array<(request: AgentInvocationRequest & { from: string }) => Promise<unknown>> = [];\nconst agentEventSubscriptions = new Map<string, Array<(event: { type: string; data: unknown; source: string }) => void>>();\n\n// Current agent ID (set after registration)\nlet currentAgentId: string | null = null;\n\n/**\n * Create the multi-agent API object.\n */\nfunction createMultiAgentApi() {\n  return Object.freeze({\n    /**\n     * Register this page as an agent.\n     * \n     * @example\n     * const agent = await window.agent.agents.register({\n     *   name: 'Researcher',\n     *   capabilities: ['search', 'summarize'],\n     *   acceptsInvocations: true,\n     * });\n     */\n    async register(options: AgentRegisterOptions): Promise<RegisteredAgent> {\n      const result = await sendRequest<RegisteredAgent>('agent.agents.register', options);\n      currentAgentId = result.id;\n      \n      // Set up event listener for incoming messages/invocations\n      setupAgentEventListener();\n      \n      return result;\n    },\n\n    /**\n     * Unregister this agent.\n     */\n    async unregister(agentId?: string): Promise<void> {\n      const idToUnregister = agentId || currentAgentId;\n      if (!idToUnregister) {\n        throw new Error('Agent not registered');\n      }\n      await sendRequest('agent.agents.unregister', { agentId: idToUnregister });\n      if (idToUnregister === currentAgentId) {\n        currentAgentId = null;\n      }\n    },\n\n    /**\n     * Get information about an agent by ID.\n     */\n    async getInfo(agentId: string): Promise<RegisteredAgent | null> {\n      return sendRequest<RegisteredAgent | null>('agent.agents.getInfo', { agentId });\n    },\n\n    /**\n     * Discover agents matching a query.\n     * \n     * @example\n     * const result = await window.agent.agents.discover({\n     *   capabilities: ['search'],\n     *   includeSameOrigin: true,\n     * });\n     * console.log('Found agents:', result.agents);\n     */\n    async discover(query: AgentDiscoveryQuery = {}): Promise<{ agents: AgentSummary[]; total: number }> {\n      return sendRequest('agent.agents.discover', query);\n    },\n\n    /**\n     * List all registered agents visible to this origin.\n     */\n    async list(): Promise<AgentSummary[]> {\n      const result = await sendRequest<{ agents: AgentSummary[] }>('agent.agents.list');\n      return result.agents;\n    },\n\n    /**\n     * Invoke another agent to perform a task.\n     * \n     * @example\n     * const response = await window.agent.agents.invoke(researcherId, {\n     *   task: 'research',\n     *   input: { topic: 'AI safety' },\n     *   timeout: 30000,\n     * });\n     */\n    async invoke(agentId: string, request: AgentInvocationRequest): Promise<AgentInvocationResponse> {\n      return sendRequest('agent.agents.invoke', { agentId, request });\n    },\n\n    /**\n     * Send a message to another agent.\n     */\n    async send(agentId: string, payload: unknown): Promise<{ delivered: boolean }> {\n      return sendRequest('agent.agents.send', { agentId, payload });\n    },\n\n    /**\n     * Register a handler for incoming messages.\n     * \n     * @example\n     * window.agent.agents.onMessage((message) => {\n     *   console.log('Received from', message.from, ':', message.payload);\n     * });\n     */\n    onMessage(handler: (message: AgentMessage) => void): () => void {\n      agentMessageHandlers.push(handler);\n      return () => {\n        const index = agentMessageHandlers.indexOf(handler);\n        if (index >= 0) agentMessageHandlers.splice(index, 1);\n      };\n    },\n\n    /**\n     * Register a handler for incoming invocations.\n     * \n     * @example\n     * window.agent.agents.onInvoke(async (request) => {\n     *   if (request.task === 'research') {\n     *     return { findings: ['...'] };\n     *   }\n     *   throw new Error('Unknown task');\n     * });\n     */\n    onInvoke(handler: (request: AgentInvocationRequest & { from: string }) => Promise<unknown>): () => void {\n      agentInvocationHandlers.push(handler);\n      return () => {\n        const index = agentInvocationHandlers.indexOf(handler);\n        if (index >= 0) agentInvocationHandlers.splice(index, 1);\n      };\n    },\n\n    /**\n     * Subscribe to events of a specific type.\n     */\n    async subscribe(eventType: string, handler: (event: { type: string; data: unknown; source: string }) => void): Promise<void> {\n      if (!agentEventSubscriptions.has(eventType)) {\n        agentEventSubscriptions.set(eventType, []);\n        // Tell background we're subscribing to this event type\n        await sendRequest('agent.agents.subscribe', { eventType });\n      }\n      agentEventSubscriptions.get(eventType)!.push(handler);\n    },\n\n    /**\n     * Unsubscribe from events of a specific type.\n     */\n    async unsubscribe(eventType: string, handler?: (event: { type: string; data: unknown; source: string }) => void): Promise<void> {\n      const handlers = agentEventSubscriptions.get(eventType);\n      if (!handlers) return;\n      \n      if (handler) {\n        const index = handlers.indexOf(handler);\n        if (index >= 0) handlers.splice(index, 1);\n      } else {\n        handlers.length = 0;\n      }\n      \n      if (handlers.length === 0) {\n        agentEventSubscriptions.delete(eventType);\n        await sendRequest('agent.agents.unsubscribe', { eventType });\n      }\n    },\n\n    /**\n     * Broadcast an event to all subscribed agents.\n     */\n    async broadcast(eventType: string, data: unknown): Promise<{ delivered: number }> {\n      return sendRequest('agent.agents.broadcast', { eventType, data });\n    },\n\n    /**\n     * Orchestration patterns for multi-agent workflows.\n     */\n    orchestrate: Object.freeze({\n      /**\n       * Execute a pipeline of agents sequentially.\n       * Each step's output becomes the next step's input.\n       * \n       * @example\n       * const result = await window.agent.agents.orchestrate.pipeline({\n       *   steps: [\n       *     { agentId: researcherId, task: 'research' },\n       *     { agentId: writerId, task: 'write' },\n       *   ],\n       * }, { topic: 'AI' });\n       */\n      async pipeline(\n        config: { steps: PipelineStep[] },\n        initialInput: unknown,\n      ): Promise<{ success: boolean; result: unknown; stepResults: unknown[] }> {\n        return sendRequest('agent.agents.orchestrate.pipeline', { config, initialInput });\n      },\n\n      /**\n       * Execute multiple agents in parallel.\n       * \n       * @example\n       * const result = await window.agent.agents.orchestrate.parallel({\n       *   tasks: [\n       *     { agentId: agent1, task: 'analyze', input: data },\n       *     { agentId: agent2, task: 'validate', input: data },\n       *   ],\n       *   combineStrategy: 'array',\n       * });\n       */\n      async parallel(\n        config: { tasks: ParallelTask[]; combineStrategy?: 'array' | 'merge' | 'first' },\n      ): Promise<{ success: boolean; results: unknown[]; combined: unknown }> {\n        return sendRequest('agent.agents.orchestrate.parallel', { config });\n      },\n\n      /**\n       * Route input to an agent based on conditions.\n       * \n       * @example\n       * const result = await window.agent.agents.orchestrate.route({\n       *   routes: [\n       *     { condition: 'type:technical', agentId: techAgent },\n       *     { condition: 'type:creative', agentId: creativeAgent },\n       *   ],\n       *   defaultAgentId: generalAgent,\n       * }, input, 'process');\n       */\n      async route(\n        config: { routes: Array<{ condition: string; agentId: string }>; defaultAgentId?: string },\n        input: unknown,\n        task: string,\n      ): Promise<AgentInvocationResponse> {\n        return sendRequest('agent.agents.orchestrate.route', { config, input, task });\n      },\n    }),\n  });\n}\n\n// Track processed invocations at the page level to prevent duplicates\nconst processedPageInvocations = new Set<string>();\n\n// Track if event listener is already set up\nlet eventListenerSetUp = false;\n\n/**\n * Set up listener for agent events (messages, invocations, broadcasts).\n * Only sets up once, no matter how many times called.\n */\nfunction setupAgentEventListener() {\n  if (eventListenerSetUp) {\n    console.log('[Web Agents API Page] Event listener already set up, skipping');\n    return;\n  }\n  eventListenerSetUp = true;\n  console.log('[Web Agents API Page] Setting up event listener');\n  \n  // Listen for agent events from the content script\n  window.addEventListener('message', async (event: MessageEvent) => {\n    if (event.source !== window) return;\n    \n    const data = event.data as {\n      channel?: string;\n      agentEvent?: {\n        type: 'message' | 'invocation' | 'broadcast';\n        message?: AgentMessage;\n        invocation?: AgentInvocationRequest & { from: string; invocationId: string };\n        broadcast?: { type: string; data: unknown; source: string };\n      };\n    };\n    \n    if (data?.channel !== 'web_agents_api' || !data.agentEvent) return;\n    \n    const { type, message, invocation, broadcast } = data.agentEvent;\n    \n    if (type === 'message' && message) {\n      // Dispatch to message handlers\n      for (const handler of agentMessageHandlers) {\n        try {\n          handler(message);\n        } catch (e) {\n          console.error('[Web Agents API] Message handler error:', e);\n        }\n      }\n    } else if (type === 'invocation' && invocation) {\n      // Deduplicate invocations\n      const invocationId = invocation.invocationId;\n      if (processedPageInvocations.has(invocationId)) {\n        console.log('[Web Agents API Page] DUPLICATE invocation, skipping:', invocationId);\n        return;\n      }\n      processedPageInvocations.add(invocationId);\n      // Clean up after 60 seconds\n      setTimeout(() => processedPageInvocations.delete(invocationId), 60000);\n      \n      console.log('[Web Agents API Page] Processing invocation:', invocation.task, invocationId);\n      \n      // Dispatch to invocation handlers and send response\n      let result: unknown;\n      let error: { code: string; message: string } | undefined;\n      \n      for (const handler of agentInvocationHandlers) {\n        try {\n          result = await handler(invocation);\n          break; // Use first handler's result\n        } catch (e) {\n          error = {\n            code: 'ERR_HANDLER_FAILED',\n            message: e instanceof Error ? e.message : 'Handler failed',\n          };\n        }\n      }\n      \n      // Send response back\n      window.postMessage({\n        channel: 'web_agents_api',\n        agentInvocationResponse: {\n          invocationId: invocation.invocationId,\n          success: !error,\n          result,\n          error,\n        },\n      }, '*');\n    } else if (type === 'broadcast' && broadcast) {\n      // Dispatch to event subscribers\n      const handlers = agentEventSubscriptions.get(broadcast.type);\n      if (handlers) {\n        for (const handler of handlers) {\n          try {\n            handler(broadcast);\n          } catch (e) {\n            console.error('[Web Agents API] Event handler error:', e);\n          }\n        }\n      }\n    }\n  });\n}\n\n// =============================================================================\n// window.agent Implementation\n// =============================================================================\n\nconst agentApi = Object.freeze({\n  async requestPermissions(options: {\n    scopes: PermissionScope[];\n    reason?: string;\n    tools?: string[];\n  }): Promise<PermissionGrantResult> {\n    return sendRequest<PermissionGrantResult>('agent.requestPermissions', options);\n  },\n\n  permissions: Object.freeze({\n    async list(): Promise<PermissionStatus> {\n      return sendRequest<PermissionStatus>('agent.permissions.list');\n    },\n  }),\n\n  tools: FEATURE_FLAGS.toolAccess\n    ? Object.freeze({\n        async list(): Promise<ToolDescriptor[]> {\n          return sendRequest<ToolDescriptor[]>('agent.tools.list');\n        },\n\n        async call(options: { tool: string; args?: Record<string, unknown> }): Promise<unknown> {\n          return sendRequest('agent.tools.call', options);\n        },\n      })\n    : {\n        list: featureDisabledAsync('toolAccess'),\n        call: featureDisabledAsync('toolAccess'),\n      },\n\n  browser: createBrowserApi(),\n\n  /**\n   * MCP (Model Context Protocol) server management.\n   * Allows websites to register MCP servers that provide tools to the user's AI.\n   */\n  mcp: Object.freeze({\n    /**\n     * Discover MCP servers declared on this page via <link rel=\"mcp-server\">.\n     * \n     * @example\n     * const servers = await window.agent.mcp.discover();\n     * console.log('Found MCP servers:', servers);\n     */\n    async discover(): Promise<Array<{\n      url: string;\n      name?: string;\n      description?: string;\n      tools?: string[];\n      transport?: string;\n    }>> {\n      return sendRequest('agent.mcp.discover');\n    },\n\n    /**\n     * Register an MCP server with the browser.\n     * \n     * @example\n     * const result = await window.agent.mcp.register({\n     *   url: 'http://localhost:3001/mcp',\n     *   name: 'My Shop Assistant',\n     *   tools: ['search_products', 'add_to_cart'],\n     *   transport: 'sse',\n     * });\n     */\n    async register(options: {\n      url: string;\n      name: string;\n      description?: string;\n      tools?: string[];\n      transport?: 'sse' | 'stdio' | 'streamable-http';\n    }): Promise<{ success: boolean; serverId?: string; error?: { code: string; message: string } }> {\n      return sendRequest('agent.mcp.register', options);\n    },\n\n    /**\n     * Unregister a previously registered MCP server.\n     */\n    async unregister(serverId: string): Promise<{ success: boolean }> {\n      return sendRequest('agent.mcp.unregister', { serverId });\n    },\n  }),\n\n  /**\n   * Browser chat UI management.\n   * Allows websites to open the user's AI chat with custom configuration.\n   */\n  chat: Object.freeze({\n    /**\n     * Check if the browser chat can be opened.\n     */\n    async canOpen(): Promise<{ available: boolean; reason?: string }> {\n      return sendRequest('agent.chat.canOpen');\n    },\n\n    /**\n     * Open the browser's chat UI with optional configuration.\n     * \n     * @example\n     * const result = await window.agent.chat.open({\n     *   systemPrompt: 'You are a helpful shopping assistant...',\n     *   tools: ['server-id/search_products', 'server-id/add_to_cart'],\n     *   style: { accentColor: '#ff9900', theme: 'light' },\n     * });\n     */\n    async open(options?: {\n      systemPrompt?: string;\n      initialMessage?: string;\n      tools?: string[];\n      style?: {\n        theme?: 'light' | 'dark' | 'auto';\n        accentColor?: string;\n        position?: 'right' | 'left';\n      };\n    }): Promise<{ success: boolean; chatId?: string; error?: { code: string; message: string } }> {\n      return sendRequest('agent.chat.open', options);\n    },\n\n    /**\n     * Close a chat opened by this origin.\n     */\n    async close(chatId: string): Promise<{ success: boolean }> {\n      return sendRequest('agent.chat.close', { chatId });\n    },\n  }),\n\n  /**\n   * Run an autonomous agent that can use tools to complete a task.\n   * \n   * @example\n   * for await (const event of window.agent.run({\n   *   task: 'What is the current time?',\n   *   maxToolCalls: 3\n   * })) {\n   *   if (event.type === 'tool_call') {\n   *     console.log('Using tool:', event.tool);\n   *   }\n   *   if (event.type === 'final') {\n   *     console.log('Response:', event.output);\n   *   }\n   * }\n   */\n  run: FEATURE_FLAGS.toolCalling\n    ? function(options: {\n        task: string;\n        maxToolCalls?: number;\n        systemPrompt?: string;\n      }): AsyncIterable<\n        | { type: 'thinking'; content: string }\n        | { type: 'tool_call'; tool: string; args: Record<string, unknown> }\n        | { type: 'tool_result'; tool: string; result: unknown }\n        | { type: 'final'; output: string }\n        | { type: 'error'; error: string }\n      > {\n        type AgentEvent =\n          | { type: 'thinking'; content: string }\n          | { type: 'tool_call'; tool: string; args: Record<string, unknown> }\n          | { type: 'tool_result'; tool: string; result: unknown }\n          | { type: 'final'; output: string }\n          | { type: 'error'; error: string };\n\n        const tokenStream = createStreamIterable<StreamToken>('agent.run', options);\n\n        return {\n          [Symbol.asyncIterator](): AsyncIterator<AgentEvent> {\n            const tokenIterator = tokenStream[Symbol.asyncIterator]();\n\n            return {\n              async next(): Promise<IteratorResult<AgentEvent>> {\n                while (true) {\n                  const result = await tokenIterator.next();\n                  \n                  if (result.done) {\n                    return { done: true, value: undefined };\n                  }\n\n                  const token = result.value;\n                  \n                  if (token.type === 'done') {\n                    return { done: true, value: undefined };\n                  }\n\n                  if (token.type === 'error') {\n                    return {\n                      done: false,\n                      value: { type: 'error', error: token.error?.message || 'Unknown error' },\n                    };\n                  }\n\n                  if (token.type === 'token' && token.token) {\n                    try {\n                      // Parse the JSON event from the token\n                      const event = JSON.parse(token.token) as AgentEvent;\n                      return { done: false, value: event };\n                    } catch {\n                      // If it's not JSON, skip this token\n                      continue;\n                    }\n                  }\n                }\n              },\n\n              async return(): Promise<IteratorResult<AgentEvent>> {\n                await tokenIterator.return?.();\n                return { done: true, value: undefined };\n              },\n            };\n          },\n        };\n      }\n    : featureDisabled('toolCalling'),\n\n  // Session management API (explicit sessions)\n  sessions: Object.freeze({\n    /**\n     * Create an explicit session with specified capabilities.\n     * \n     * @example\n     * const session = await agent.sessions.create({\n     *   name: 'Recipe Assistant',\n     *   capabilities: {\n     *     llm: { provider: 'ollama' },\n     *     tools: ['time-wasm/time.now'],\n     *   },\n     *   limits: { maxToolCalls: 10 },\n     * });\n     * \n     * const response = await session.prompt('What time is it?');\n     */\n    async create(options: CreateSessionOptions): Promise<AgentSession> {\n      const result = await sendRequest<CreateSessionResult>('agent.sessions.create', options);\n      \n      if (!result.success || !result.sessionId || !result.capabilities) {\n        const errorMsg = result.error?.message || 'Session creation failed';\n        throw new Error(errorMsg);\n      }\n      \n      return createAgentSessionObject(result.sessionId, result.capabilities);\n    },\n\n    /**\n     * Get a session by ID.\n     */\n    async get(sessionId: string): Promise<SessionSummary | null> {\n      return sendRequest<SessionSummary | null>('agent.sessions.get', { sessionId });\n    },\n\n    /**\n     * List active sessions for this origin.\n     */\n    async list(): Promise<SessionSummary[]> {\n      return sendRequest<SessionSummary[]>('agent.sessions.list');\n    },\n\n    /**\n     * Terminate a session.\n     */\n    async terminate(sessionId: string): Promise<boolean> {\n      const result = await sendRequest<{ terminated: boolean }>('agent.sessions.terminate', { sessionId });\n      return result.terminated;\n    },\n  }),\n\n  // Multi-agent API (Extension 3)\n  agents: FEATURE_FLAGS.multiAgent\n    ? createMultiAgentApi()\n    : {\n        register: featureDisabledAsync('multiAgent'),\n        unregister: featureDisabledAsync('multiAgent'),\n        getInfo: featureDisabledAsync('multiAgent'),\n        discover: featureDisabledAsync('multiAgent'),\n        list: featureDisabledAsync('multiAgent'),\n        invoke: featureDisabledAsync('multiAgent'),\n        send: featureDisabledAsync('multiAgent'),\n        onMessage: featureDisabled('multiAgent'),\n        onInvoke: featureDisabled('multiAgent'),\n        subscribe: featureDisabledAsync('multiAgent'),\n        unsubscribe: featureDisabledAsync('multiAgent'),\n        orchestrate: {\n          pipeline: featureDisabledAsync('multiAgent'),\n          parallel: featureDisabledAsync('multiAgent'),\n          route: featureDisabledAsync('multiAgent'),\n        },\n      },\n});\n\n// =============================================================================\n// Register Global APIs\n// =============================================================================\n\n/**\n * Safely define a property on window.\n */\nfunction safeDefineProperty(\n  name: string,\n  value: unknown,\n): boolean {\n  try {\n    const descriptor = Object.getOwnPropertyDescriptor(window, name);\n    if (descriptor && !descriptor.configurable) {\n      console.debug(`[Web Agents API] Skipping ${name} - already defined`);\n      return false;\n    }\n\n    Object.defineProperty(window, name, {\n      value,\n      writable: false,\n      configurable: true,\n      enumerable: true,\n    });\n    return true;\n  } catch (error) {\n    console.debug(`[Web Agents API] Could not define window.${name}:`, error);\n    return false;\n  }\n}\n\ntry {\n  // Check if Chrome AI is already present\n  const existingAi = (window as { ai?: unknown }).ai;\n  const chromeAiDetected = existingAi !== undefined && existingAi !== null;\n\n  // Register window.ai (skip if Chrome AI is present, or if textGeneration is disabled)\n  if (FEATURE_FLAGS.textGeneration && !chromeAiDetected) {\n    safeDefineProperty('ai', aiApi);\n  } else if (!FEATURE_FLAGS.textGeneration) {\n    console.debug('[Web Agents API] Text generation disabled, window.ai not registered.');\n  } else {\n    console.debug('[Web Agents API] Chrome AI detected, window.ai not overridden.');\n  }\n\n  // Register window.agent\n  const existingAgent = (window as { agent?: unknown }).agent;\n  if (existingAgent === undefined) {\n    safeDefineProperty('agent', agentApi);\n  }\n\n  // Dispatch ready event with feature flags info\n  window.dispatchEvent(\n    new CustomEvent('agent-ready', {\n      detail: {\n        version: '1.0.0',\n        chromeAiDetected,\n        features: {\n          textGeneration: FEATURE_FLAGS.textGeneration,\n          toolCalling: FEATURE_FLAGS.toolCalling,\n          toolAccess: FEATURE_FLAGS.toolAccess,\n          browserInteraction: FEATURE_FLAGS.browserInteraction,\n          browserControl: FEATURE_FLAGS.browserControl,\n          multiAgent: FEATURE_FLAGS.multiAgent,\n        },\n      },\n    }),\n  );\n  \n  console.debug('[Web Agents API] Registered with features:', FEATURE_FLAGS);\n} catch (error) {\n  console.warn('[Web Agents API] Failed to register API', error);\n}\n"],
  "mappings": "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",
  "names": []
}
