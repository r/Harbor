{
  "version": 3,
  "sources": ["../src/browser-compat.ts", "../src/storage/package-loader.ts", "../src/directory.ts"],
  "sourcesContent": ["/**\n * Browser Compatibility Layer\n *\n * Provides a unified API for browser extension functionality across\n * Firefox, Chrome, and Safari.\n *\n * Firefox uses `browser.*` APIs with native Promise support.\n * Chrome uses `chrome.*` APIs (Promise-based in MV3).\n * Safari uses `browser.*` APIs similar to Firefox.\n */\n\n// Detect environment and provide unified API\ndeclare const browser: typeof chrome | undefined;\n\n/**\n * Unified browser API that works across Firefox, Chrome, and Safari.\n * Prefers `browser` namespace (Firefox/Safari) but falls back to `chrome` (Chrome).\n */\nexport const browserAPI = (typeof browser !== 'undefined' ? browser : chrome) as typeof chrome;\n\n/**\n * Get the URL for an extension resource.\n * Safari doesn't have runtime.getURL in all contexts, so we fall back to relative URLs.\n */\nexport function getExtensionURL(path: string): string {\n  // Try runtime.getURL first (works in Firefox, Chrome, and Safari background)\n  if (browserAPI.runtime?.getURL) {\n    return browserAPI.runtime.getURL(path);\n  }\n  \n  // Fallback for Safari popup/sidebar where runtime.getURL doesn't exist\n  // Use relative URL from the extension's base\n  return path;\n}\n\n/**\n * Check if running in Firefox.\n */\nexport function isFirefox(): boolean {\n  return typeof browser !== 'undefined' && navigator.userAgent.includes('Firefox');\n}\n\n/**\n * Check if running in Chrome.\n */\nexport function isChrome(): boolean {\n  return typeof browser === 'undefined' && typeof chrome !== 'undefined';\n}\n\n/**\n * Check if running in Safari.\n */\nexport function isSafari(): boolean {\n  return typeof browser !== 'undefined' && navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome');\n}\n\n/**\n * Check if the Firefox ML API (browser.trial.ml) is available.\n * Only available in Firefox 134+ with the trialML permission.\n */\nexport function hasFirefoxML(): boolean {\n  if (typeof browser === 'undefined') return false;\n  const trial = (browser as unknown as { trial?: { ml?: unknown } }).trial;\n  return !!trial && !!trial.ml;\n}\n\n/**\n * Check if the Firefox wllama API is available.\n * Only available in Firefox 142+ with the trialML permission.\n */\nexport function hasFirefoxWllama(): boolean {\n  if (typeof browser === 'undefined') return false;\n  const trial = (browser as unknown as { trial?: { ml?: { wllama?: unknown } } }).trial;\n  return !!trial?.ml?.wllama;\n}\n\n/**\n * Check if the sidebar_action API is available.\n * Only available in Firefox.\n */\nexport function hasSidebar(): boolean {\n  return typeof browser !== 'undefined' && 'sidebarAction' in browser;\n}\n\n/**\n * Check if running in a service worker context.\n * Chrome MV3 uses service workers for the background script.\n */\nexport function isServiceWorker(): boolean {\n  return typeof ServiceWorkerGlobalScope !== 'undefined' &&\n    self instanceof ServiceWorkerGlobalScope;\n}\n\n/**\n * Check if the scripting API is available.\n * Available in MV3 extensions on both Chrome and Firefox.\n */\nexport function hasScriptingAPI(): boolean {\n  return 'scripting' in browserAPI;\n}\n\n/**\n * Execute a script in a tab, compatible with both Chrome and Firefox.\n * Falls back to tabs.executeScript for older Firefox versions.\n */\nexport async function executeScriptInTab<T>(\n  tabId: number,\n  func: (...args: unknown[]) => T,\n  args: unknown[] = []\n): Promise<T | undefined> {\n  // Try chrome.scripting first (Chrome MV3, Firefox MV3 with scripting)\n  if (browserAPI.scripting?.executeScript) {\n    const results = await browserAPI.scripting.executeScript({\n      target: { tabId },\n      func: func as () => T,\n      args,\n    });\n    return results?.[0]?.result as T | undefined;\n  }\n\n  // Fallback: browser.tabs.executeScript (Firefox MV2 style)\n  if (typeof browser !== 'undefined' && browser.tabs?.executeScript) {\n    // For this fallback, we need to serialize the function\n    const code = `(${func.toString()}).apply(null, ${JSON.stringify(args)})`;\n    const results = await browser.tabs.executeScript(tabId, { code });\n    return results?.[0] as T | undefined;\n  }\n\n  throw new Error('No script execution API available');\n}\n\n/**\n * Get the current browser name for logging and debugging.\n */\nexport function getBrowserName(): 'firefox' | 'chrome' | 'safari' | 'unknown' {\n  if (isFirefox()) return 'firefox';\n  if (isSafari()) return 'safari';\n  if (isChrome()) return 'chrome';\n  return 'unknown';\n}\n\n/**\n * Log with browser context for debugging.\n */\nexport function logWithBrowser(prefix: string, ...args: unknown[]): void {\n  console.log(`[${prefix}:${getBrowserName()}]`, ...args);\n}\n\n/**\n * Check if the omnibox API is available.\n * Available in Firefox and Chrome, but may have different features.\n */\nexport function hasOmnibox(): boolean {\n  return 'omnibox' in browserAPI;\n}\n\n/**\n * Check if externally_connectable is available.\n * Only Chrome supports onMessageExternal/onConnectExternal.\n */\nexport function hasExternalMessaging(): boolean {\n  return 'onMessageExternal' in browserAPI.runtime;\n}\n\n/**\n * Check if web navigation API is available.\n */\nexport function hasWebNavigation(): boolean {\n  return 'webNavigation' in browserAPI;\n}\n\n/**\n * Check if this is MV3 (Manifest Version 3).\n */\nexport function isManifestV3(): boolean {\n  return browserAPI.runtime.getManifest().manifest_version === 3;\n}\n\n/**\n * Service worker lifecycle handlers for Chrome MV3.\n * These help maintain state across service worker restarts.\n */\nexport const serviceWorkerLifecycle = {\n  /**\n   * Register a startup handler that runs when the service worker starts.\n   * This is useful for restoring state in Chrome MV3.\n   */\n  onStartup(handler: () => void): void {\n    if (browserAPI.runtime.onStartup) {\n      browserAPI.runtime.onStartup.addListener(handler);\n    }\n  },\n\n  /**\n   * Register an install/update handler.\n   * Runs on first install or extension update.\n   */\n  onInstalled(handler: (details: { reason: string; previousVersion?: string }) => void): void {\n    if (browserAPI.runtime.onInstalled) {\n      browserAPI.runtime.onInstalled.addListener(handler);\n    }\n  },\n\n  /**\n   * Register a suspend handler (Chrome MV3 only).\n   * Called when the service worker is about to be terminated.\n   */\n  onSuspend(handler: () => void): void {\n    if (isServiceWorker() && 'onSuspend' in browserAPI.runtime) {\n      (browserAPI.runtime as { onSuspend: { addListener: (h: () => void) => void } }).onSuspend.addListener(handler);\n    }\n  },\n\n  /**\n   * Keep the service worker alive (Chrome MV3).\n   * Use sparingly - Chrome will still terminate after 5 minutes.\n   */\n  keepAlive(): void {\n    if (isServiceWorker()) {\n      // Accessing chrome.storage periodically can help keep the worker alive\n      // but this should be used sparingly\n      setInterval(() => {\n        browserAPI.storage.local.get(null);\n      }, 20000); // Every 20 seconds\n    }\n  }\n};\n\n/**\n * Browser feature summary for debugging.\n */\nexport function getFeatureSummary(): Record<string, boolean | string> {\n  return {\n    browser: getBrowserName(),\n    isServiceWorker: isServiceWorker(),\n    isManifestV3: isManifestV3(),\n    hasSidebar: hasSidebar(),\n    hasOmnibox: hasOmnibox(),\n    hasFirefoxML: hasFirefoxML(),\n    hasFirefoxWllama: hasFirefoxWllama(),\n    hasScriptingAPI: hasScriptingAPI(),\n    hasExternalMessaging: hasExternalMessaging(),\n    hasWebNavigation: hasWebNavigation(),\n  };\n}\n", "/**\n * MCP Server Package Loader\n * \n * Handles loading MCP servers from various package formats:\n * 1. Single-file distributable JSON (.json, .mcp.json) - manifest with embedded base64 code\n * 2. Zip package (.zip, .mcp.zip) - contains manifest.json + server files\n * 3. URL manifest - manifest.json with scriptUrl/wasmUrl pointing to hosted files\n * \n * All formats are normalized to McpServerManifest with embedded code (scriptBase64/wasmBase64).\n */\n\nimport type { McpServerManifest } from '../wasm/types';\n\nexport type PackageFormat = 'distributable' | 'zip' | 'manifest-url';\n\nexport type LoadResult = {\n  success: true;\n  manifest: McpServerManifest;\n  format: PackageFormat;\n  sourceUrl?: string;\n} | {\n  success: false;\n  error: string;\n};\n\n/**\n * Detect package format from URL or content type.\n */\nexport function detectFormat(url: string, contentType?: string): PackageFormat {\n  const lowerUrl = url.toLowerCase();\n  \n  // Check by extension first\n  if (lowerUrl.endsWith('.zip') || lowerUrl.endsWith('.mcp.zip')) {\n    return 'zip';\n  }\n  \n  // Check content type\n  if (contentType) {\n    if (contentType.includes('application/zip') || contentType.includes('application/x-zip')) {\n      return 'zip';\n    }\n  }\n  \n  // Default to distributable JSON (which can also be a manifest-url)\n  return 'distributable';\n}\n\n/**\n * Load an MCP server package from a URL.\n * Automatically detects format and normalizes to McpServerManifest.\n */\nexport async function loadFromUrl(url: string): Promise<LoadResult> {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      return { success: false, error: `Failed to fetch: ${response.status} ${response.statusText}` };\n    }\n    \n    const contentType = response.headers.get('content-type') || '';\n    const format = detectFormat(url, contentType);\n    \n    if (format === 'zip') {\n      return loadZipPackage(await response.arrayBuffer(), url);\n    } else {\n      return loadJsonPackage(await response.text(), url);\n    }\n  } catch (err) {\n    return { success: false, error: `Network error: ${err instanceof Error ? err.message : String(err)}` };\n  }\n}\n\n/**\n * Load from a File object (for drag-drop or file input).\n */\nexport async function loadFromFile(file: File): Promise<LoadResult> {\n  try {\n    const format = detectFormat(file.name, file.type);\n    \n    if (format === 'zip') {\n      return loadZipPackage(await file.arrayBuffer(), file.name);\n    } else {\n      return loadJsonPackage(await file.text(), file.name);\n    }\n  } catch (err) {\n    return { success: false, error: `File read error: ${err instanceof Error ? err.message : String(err)}` };\n  }\n}\n\n/**\n * Load a JSON package (distributable or manifest-url).\n */\nasync function loadJsonPackage(jsonText: string, sourceUrl: string): Promise<LoadResult> {\n  let manifest: McpServerManifest;\n  \n  try {\n    manifest = JSON.parse(jsonText);\n  } catch (err) {\n    return { success: false, error: 'Invalid JSON' };\n  }\n  \n  // Validate required fields\n  if (!manifest.id || !manifest.name) {\n    return { success: false, error: 'Missing required fields: id and name' };\n  }\n  \n  // Check if it's already a distributable (has embedded code)\n  if (manifest.scriptBase64 || manifest.wasmBase64 || manifest.moduleBytesBase64) {\n    return { \n      success: true, \n      manifest, \n      format: 'distributable',\n      sourceUrl \n    };\n  }\n  \n  // It's a manifest-url - need to fetch the code\n  const baseUrl = sourceUrl.substring(0, sourceUrl.lastIndexOf('/') + 1);\n  \n  if (manifest.runtime === 'js' && manifest.scriptUrl) {\n    const scriptFullUrl = resolveUrl(manifest.scriptUrl, baseUrl);\n    const scriptResult = await fetchCode(scriptFullUrl);\n    \n    if (!scriptResult.success) {\n      return { success: false, error: `Failed to load script: ${scriptResult.error}` };\n    }\n    \n    // Embed the code as base64\n    manifest = {\n      ...manifest,\n      scriptBase64: btoa(unescape(encodeURIComponent(scriptResult.code))),\n      scriptUrl: undefined, // Remove URL since code is now embedded\n    };\n    \n    return { success: true, manifest, format: 'manifest-url', sourceUrl };\n  }\n  \n  if (manifest.runtime === 'wasm' && (manifest.moduleUrl || manifest.wasmUrl)) {\n    const wasmUrl = manifest.moduleUrl || manifest.wasmUrl;\n    const wasmFullUrl = resolveUrl(wasmUrl!, baseUrl);\n    const wasmResult = await fetchBinary(wasmFullUrl);\n    \n    if (!wasmResult.success) {\n      return { success: false, error: `Failed to load WASM: ${wasmResult.error}` };\n    }\n    \n    // Embed the WASM as base64\n    manifest = {\n      ...manifest,\n      wasmBase64: arrayBufferToBase64(wasmResult.data),\n      moduleUrl: undefined,\n      wasmUrl: undefined,\n    };\n    \n    return { success: true, manifest, format: 'manifest-url', sourceUrl };\n  }\n  \n  return { success: false, error: 'No executable code found (missing scriptUrl, scriptBase64, moduleUrl, or wasmBase64)' };\n}\n\n/**\n * Load a ZIP package.\n * Expects the zip to contain:\n * - manifest.json (required)\n * - server code file (referenced by scriptUrl or moduleUrl in manifest)\n */\nasync function loadZipPackage(data: ArrayBuffer, sourceUrl: string): Promise<LoadResult> {\n  try {\n    // Use JSZip if available, otherwise fall back to manual extraction\n    const files = await extractZip(data);\n    \n    // Find manifest.json\n    const manifestEntry = files.find(f => \n      f.name === 'manifest.json' || \n      f.name.endsWith('/manifest.json')\n    );\n    \n    if (!manifestEntry) {\n      return { success: false, error: 'No manifest.json found in zip' };\n    }\n    \n    let manifest: McpServerManifest;\n    try {\n      manifest = JSON.parse(new TextDecoder().decode(manifestEntry.data));\n    } catch {\n      return { success: false, error: 'Invalid manifest.json in zip' };\n    }\n    \n    // Validate required fields\n    if (!manifest.id || !manifest.name) {\n      return { success: false, error: 'Missing required fields: id and name' };\n    }\n    \n    // Find and embed the code\n    if (manifest.runtime === 'js' && manifest.scriptUrl) {\n      const scriptName = manifest.scriptUrl.replace(/^\\.?\\//, '');\n      const scriptEntry = files.find(f => \n        f.name === scriptName || \n        f.name.endsWith('/' + scriptName) ||\n        f.name === 'server.js' ||\n        f.name.endsWith('.js')\n      );\n      \n      if (!scriptEntry) {\n        return { success: false, error: `Script file not found in zip: ${manifest.scriptUrl}` };\n      }\n      \n      const scriptText = new TextDecoder().decode(scriptEntry.data);\n      manifest = {\n        ...manifest,\n        scriptBase64: btoa(unescape(encodeURIComponent(scriptText))),\n        scriptUrl: undefined,\n      };\n    } else if (manifest.runtime === 'wasm' && (manifest.moduleUrl || manifest.wasmUrl || manifest.entrypoint)) {\n      const wasmName = (manifest.moduleUrl || manifest.wasmUrl || manifest.entrypoint || '').replace(/^\\.?\\//, '');\n      const wasmEntry = files.find(f => \n        f.name === wasmName || \n        f.name.endsWith('/' + wasmName) ||\n        f.name.endsWith('.wasm')\n      );\n      \n      if (!wasmEntry) {\n        return { success: false, error: `WASM file not found in zip: ${wasmName}` };\n      }\n      \n      manifest = {\n        ...manifest,\n        wasmBase64: arrayBufferToBase64(wasmEntry.data),\n        moduleUrl: undefined,\n        wasmUrl: undefined,\n      };\n    } else if (!manifest.scriptBase64 && !manifest.wasmBase64 && !manifest.moduleBytesBase64) {\n      return { success: false, error: 'No executable code found in manifest or zip' };\n    }\n    \n    return { success: true, manifest, format: 'zip', sourceUrl };\n  } catch (err) {\n    return { success: false, error: `Zip extraction failed: ${err instanceof Error ? err.message : String(err)}` };\n  }\n}\n\n/**\n * Extract files from a ZIP archive.\n * Uses a simple ZIP parser - no external dependencies.\n */\nasync function extractZip(data: ArrayBuffer): Promise<Array<{ name: string; data: Uint8Array }>> {\n  const view = new DataView(data);\n  const files: Array<{ name: string; data: Uint8Array }> = [];\n  \n  let offset = 0;\n  const bytes = new Uint8Array(data);\n  \n  while (offset < data.byteLength - 4) {\n    // Check for local file header signature (0x04034b50)\n    const sig = view.getUint32(offset, true);\n    if (sig !== 0x04034b50) {\n      // Not a local file header - might be central directory, stop here\n      break;\n    }\n    \n    // Read local file header\n    const compressionMethod = view.getUint16(offset + 8, true);\n    const compressedSize = view.getUint32(offset + 18, true);\n    const uncompressedSize = view.getUint32(offset + 22, true);\n    const fileNameLength = view.getUint16(offset + 26, true);\n    const extraFieldLength = view.getUint16(offset + 28, true);\n    \n    const fileNameStart = offset + 30;\n    const fileName = new TextDecoder().decode(bytes.slice(fileNameStart, fileNameStart + fileNameLength));\n    \n    const dataStart = fileNameStart + fileNameLength + extraFieldLength;\n    const dataEnd = dataStart + compressedSize;\n    const compressedData = bytes.slice(dataStart, dataEnd);\n    \n    // Skip directories\n    if (!fileName.endsWith('/')) {\n      let fileData: Uint8Array;\n      \n      if (compressionMethod === 0) {\n        // Stored (no compression)\n        fileData = compressedData;\n      } else if (compressionMethod === 8) {\n        // Deflate compression - use DecompressionStream if available\n        try {\n          const ds = new DecompressionStream('deflate-raw');\n          const writer = ds.writable.getWriter();\n          writer.write(compressedData);\n          writer.close();\n          \n          const reader = ds.readable.getReader();\n          const chunks: Uint8Array[] = [];\n          \n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) break;\n            chunks.push(value);\n          }\n          \n          // Concatenate chunks\n          const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);\n          fileData = new Uint8Array(totalLength);\n          let pos = 0;\n          for (const chunk of chunks) {\n            fileData.set(chunk, pos);\n            pos += chunk.length;\n          }\n        } catch (err) {\n          console.warn(`Failed to decompress ${fileName}:`, err);\n          // Try treating as uncompressed\n          fileData = compressedData;\n        }\n      } else {\n        console.warn(`Unknown compression method ${compressionMethod} for ${fileName}`);\n        fileData = compressedData;\n      }\n      \n      files.push({ name: fileName, data: fileData });\n    }\n    \n    offset = dataEnd;\n  }\n  \n  return files;\n}\n\n/**\n * Resolve a relative URL against a base URL.\n */\nfunction resolveUrl(url: string, baseUrl: string): string {\n  if (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('chrome-extension://')) {\n    return url;\n  }\n  \n  // Handle relative paths\n  if (url.startsWith('./')) {\n    url = url.slice(2);\n  }\n  \n  return baseUrl + url;\n}\n\n/**\n * Fetch code (text) from a URL.\n */\nasync function fetchCode(url: string): Promise<{ success: true; code: string } | { success: false; error: string }> {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      return { success: false, error: `${response.status} ${response.statusText}` };\n    }\n    return { success: true, code: await response.text() };\n  } catch (err) {\n    return { success: false, error: err instanceof Error ? err.message : String(err) };\n  }\n}\n\n/**\n * Fetch binary data from a URL.\n */\nasync function fetchBinary(url: string): Promise<{ success: true; data: ArrayBuffer } | { success: false; error: string }> {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      return { success: false, error: `${response.status} ${response.statusText}` };\n    }\n    return { success: true, data: await response.arrayBuffer() };\n  } catch (err) {\n    return { success: false, error: err instanceof Error ? err.message : String(err) };\n  }\n}\n\n/**\n * Convert ArrayBuffer to base64 string.\n */\nfunction arrayBufferToBase64(buffer: ArrayBuffer | Uint8Array): string {\n  const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n  let binary = '';\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\n", "/**\n * Harbor Directory - Bundled MCP Servers\n * \n * Shows a list of bundled/curated MCP servers that can be installed with one click.\n * Supports installing from:\n * - Bundled servers (shipped with extension)\n * - URL (single-file distributable, zip package, or manifest URL)\n * - File upload (drag-drop or file picker)\n */\n\nimport { browserAPI } from './browser-compat';\nimport { loadFromUrl, loadFromFile, type LoadResult } from './storage/package-loader';\n// NOTE: Feature flags are enforced by Web Agents API extension, not Harbor\n\n// Make this a module to avoid global scope conflicts\nexport {};\n\ntype BundledServer = {\n  id: string;\n  name: string;\n  description: string;\n  version: string;\n  runtime: 'js' | 'wasm' | 'remote';\n  icon: string;\n  tags: string[];\n  manifestUrl?: string;\n  wasmUrl?: string;\n  builtIn?: boolean; // Pre-installed with extension, can't be installed from directory\n  // Remote server configuration\n  remoteUrl?: string;\n  remoteTransport?: 'sse' | 'websocket';\n  tools: Array<{\n    name: string;\n    description?: string;\n  }>;\n  // OAuth configuration\n  oauth?: {\n    provider: 'google' | 'github';\n    scopes: string[];\n  };\n};\n\ntype InstalledServer = {\n  id: string;\n  name: string;\n  version: string;\n  runtime?: 'wasm' | 'js';\n  entrypoint?: string;\n  tools?: Array<{ name: string }>;\n  running: boolean;\n};\n\n// Bundled servers that ship with Harbor\nconst BUNDLED_SERVERS: BundledServer[] = [\n  {\n    id: 'time-wasm',\n    name: 'Time Server',\n    description: 'Provides tools for getting the current time and converting between timezones. A simple WASM-based MCP server.',\n    version: '1.0.0',\n    runtime: 'wasm',\n    icon: '\uD83D\uDD50',\n    tags: ['time', 'datetime', 'timezone', 'wasm'],\n    wasmUrl: 'assets/mcp-time.wasm',\n    tools: [\n      { name: 'get_current_time', description: 'Get the current time in a specific timezone' },\n      { name: 'convert_time', description: 'Convert time between timezones' },\n    ],\n  },\n  {\n    id: 'echo-js',\n    name: 'Echo Server',\n    description: 'A simple demo server that echoes back input and reverses strings. Useful for testing MCP tool calls.',\n    version: '1.0.0',\n    runtime: 'js',\n    icon: '\uD83D\uDD0A',\n    tags: ['demo', 'test', 'echo'],\n    builtIn: true,\n    tools: [\n      { name: 'echo', description: 'Echo back the input message' },\n      { name: 'reverse', description: 'Reverse a string' },\n    ],\n  },\n  {\n    id: 'gmail-harbor',\n    name: 'Gmail (Harbor)',\n    description: 'Read and send emails via Gmail API. Supports searching, reading, sending emails and managing labels. Requires Google OAuth.',\n    version: '1.0.0',\n    runtime: 'js',\n    icon: '\uD83D\uDCE7',\n    tags: ['gmail', 'email', 'google', 'oauth'],\n    manifestUrl: 'bundled/gmail-harbor/manifest.json',\n    tools: [\n      { name: 'search_emails', description: 'Search emails using Gmail query syntax' },\n      { name: 'read_email', description: 'Read the full content of an email' },\n      { name: 'send_email', description: 'Send a new email' },\n      { name: 'list_email_labels', description: 'List all Gmail labels' },\n      { name: 'modify_email', description: 'Add or remove labels from emails' },\n      { name: 'delete_email', description: 'Permanently delete an email' },\n    ],\n    oauth: {\n      provider: 'google',\n      scopes: [\n        'https://www.googleapis.com/auth/gmail.readonly',\n        'https://www.googleapis.com/auth/gmail.send',\n        'https://www.googleapis.com/auth/gmail.modify',\n      ],\n    },\n  },\n  // Example remote server (from the bring-your-chatbot demo)\n  {\n    id: 'acme-shop-remote',\n    name: 'Acme Shop (Demo)',\n    description: 'Example remote MCP server from the bring-your-chatbot demo. Runs locally on port 3001. Search products, manage cart, and get recommendations.',\n    version: '1.0.0',\n    runtime: 'remote',\n    icon: '\uD83D\uDED2',\n    tags: ['demo', 'remote', 'shop', 'sse'],\n    remoteUrl: 'http://localhost:3001/mcp',\n    remoteTransport: 'sse',\n    tools: [\n      { name: 'search_products', description: 'Search the product catalog' },\n      { name: 'get_product_details', description: 'Get details of a product' },\n      { name: 'add_to_cart', description: 'Add item to cart' },\n      { name: 'get_cart', description: 'View cart contents' },\n    ],\n  },\n];\n\nconst STORAGE_KEY = 'harbor_wasm_servers';\n\n// DOM elements\nconst list = document.getElementById('list') as HTMLDivElement;\nconst themeToggle = document.getElementById('theme-toggle') as HTMLButtonElement;\nconst installUrlInput = document.getElementById('install-url') as HTMLInputElement;\nconst installUrlBtn = document.getElementById('install-url-btn') as HTMLButtonElement;\nconst dropZone = document.getElementById('drop-zone') as HTMLDivElement;\nconst fileInput = document.getElementById('file-input') as HTMLInputElement;\n\n// Track installed servers\nlet installedServerIds = new Set<string>();\n\nfunction renderServerCard(server: BundledServer): HTMLElement {\n  const isInstalled = installedServerIds.has(server.id) || server.builtIn;\n  \n  const card = document.createElement('div');\n  card.className = `server-card ${isInstalled ? 'installed' : ''}`;\n  card.dataset.serverId = server.id;\n\n  const header = document.createElement('div');\n  header.className = 'server-card-header';\n\n  const iconContainer = document.createElement('div');\n  iconContainer.className = 'server-card-icon';\n  iconContainer.textContent = server.icon;\n\n  const info = document.createElement('div');\n  info.className = 'server-card-info';\n\n  const nameRow = document.createElement('div');\n  nameRow.className = 'server-card-name-row';\n\n  const name = document.createElement('span');\n  name.className = 'server-card-name';\n  name.textContent = server.name;\n\n  const badges = document.createElement('div');\n  badges.className = 'server-card-badges';\n\n  const runtimeBadge = document.createElement('span');\n  const runtimeClass = server.runtime === 'wasm' ? 'wasm' : server.runtime === 'remote' ? 'remote' : 'js';\n  runtimeBadge.className = `badge badge-${runtimeClass}`;\n  runtimeBadge.textContent = server.runtime.toUpperCase();\n  badges.appendChild(runtimeBadge);\n\n  if (server.builtIn) {\n    const builtInBadge = document.createElement('span');\n    builtInBadge.className = 'badge badge-builtin';\n    builtInBadge.textContent = 'Built-in';\n    badges.appendChild(builtInBadge);\n  } else if (isInstalled) {\n    const installedBadge = document.createElement('span');\n    installedBadge.className = 'badge badge-installed';\n    installedBadge.textContent = 'Installed';\n    badges.appendChild(installedBadge);\n  }\n\n  // OAuth badge (just informational, no separate sign-in flow needed)\n  if (server.oauth) {\n    const oauthBadge = document.createElement('span');\n    oauthBadge.className = 'badge badge-warning';\n    oauthBadge.textContent = 'Requires OAuth';\n    badges.appendChild(oauthBadge);\n  }\n\n  nameRow.appendChild(name);\n  nameRow.appendChild(badges);\n\n  const desc = document.createElement('div');\n  desc.className = 'server-card-desc';\n  desc.textContent = server.description;\n\n  info.appendChild(nameRow);\n  info.appendChild(desc);\n\n  header.appendChild(iconContainer);\n  header.appendChild(info);\n\n  // Tools section\n  const tools = document.createElement('div');\n  tools.className = 'server-card-tools';\n  \n  const toolsLabel = document.createElement('span');\n  toolsLabel.className = 'tools-label';\n  toolsLabel.textContent = 'Tools: ';\n  tools.appendChild(toolsLabel);\n  \n  const toolsList = server.tools.map(t => t.name).join(', ');\n  const toolsText = document.createElement('span');\n  toolsText.className = 'tools-list';\n  toolsText.textContent = toolsList;\n  tools.appendChild(toolsText);\n\n  // Tags\n  const tags = document.createElement('div');\n  tags.className = 'server-card-tags';\n  server.tags.forEach((tag) => {\n    const tagEl = document.createElement('span');\n    tagEl.className = 'tag';\n    tagEl.textContent = tag;\n    tags.appendChild(tagEl);\n  });\n\n  // Action buttons\n  const actions = document.createElement('div');\n  actions.className = 'server-card-actions';\n\n  if (!server.builtIn) {\n    const installBtn = document.createElement('button');\n    installBtn.className = `btn ${isInstalled ? 'btn-secondary' : 'btn-primary'}`;\n    installBtn.textContent = isInstalled ? 'Uninstall' : 'Install';\n    installBtn.addEventListener('click', (e) => {\n      e.stopPropagation();\n      if (isInstalled) {\n        uninstallServer(server);\n      } else {\n        installServer(server);\n      }\n    });\n    actions.appendChild(installBtn);\n  }\n\n  card.appendChild(header);\n  card.appendChild(tools);\n  card.appendChild(tags);\n  card.appendChild(actions);\n\n  return card;\n}\n\nasync function loadInstalledServers(): Promise<void> {\n  try {\n    const response = await browserAPI.runtime.sendMessage({ type: 'sidebar_get_servers' });\n    console.log('[Directory] Got servers response:', response);\n    if (response?.ok && response.servers) {\n      const serverIds = response.servers.map((s: InstalledServer) => s.id);\n      console.log('[Directory] Installed server IDs:', serverIds);\n      installedServerIds = new Set(serverIds);\n    } else {\n      // Also check storage directly for WASM servers\n      const result = await browserAPI.storage.local.get(STORAGE_KEY);\n      const servers = (result[STORAGE_KEY] as Array<{ id: string }>) || [];\n      const serverIds = servers.map((s) => s.id);\n      console.log('[Directory] Storage server IDs:', serverIds);\n      installedServerIds = new Set(serverIds);\n    }\n    console.log('[Directory] Final installedServerIds:', [...installedServerIds]);\n  } catch (err) {\n    console.error('[Directory] Failed to load installed servers:', err);\n  }\n}\n\nasync function installServer(server: BundledServer): Promise<void> {\n  const btn = document.querySelector(`[data-server-id=\"${server.id}\"] .btn`) as HTMLButtonElement;\n  if (btn) {\n    btn.disabled = true;\n    btn.textContent = 'Installing...';\n  }\n\n  try {\n    if (server.runtime === 'remote' && server.remoteUrl) {\n      // Install remote server\n      const response = await browserAPI.runtime.sendMessage({\n        type: 'sidebar_add_remote_server',\n        url: server.remoteUrl,\n        name: server.name,\n        transport: server.remoteTransport || 'sse',\n      });\n\n      if (!response?.ok) {\n        throw new Error(response?.error || 'Failed to connect to remote server');\n      }\n\n      installedServerIds.add(server.id);\n      showToast(`Connected to ${server.name}`, 'success');\n      refreshList();\n      return;\n    } else if (server.runtime === 'wasm' && server.wasmUrl) {\n      // Load WASM module\n      const wasmResponse = await fetch(browserAPI.runtime.getURL(server.wasmUrl));\n      const wasmBytes = await wasmResponse.arrayBuffer();\n      \n      const manifest = {\n        id: server.id,\n        name: server.name,\n        version: server.version,\n        runtime: 'wasm',\n        entrypoint: server.wasmUrl,\n        moduleBytesBase64: btoa(String.fromCharCode(...new Uint8Array(wasmBytes))),\n        permissions: [],\n        tools: server.tools,\n      };\n\n      const response = await browserAPI.runtime.sendMessage({\n        type: 'sidebar_install_server',\n        manifest,\n      });\n\n      if (!response?.ok) {\n        throw new Error(response?.error || 'Failed to install server');\n      }\n\n      // Start the server\n      await browserAPI.runtime.sendMessage({\n        type: 'sidebar_validate_server',\n        serverId: server.id,\n      });\n    } else if (server.runtime === 'js' && server.manifestUrl) {\n      // Load JS manifest\n      const manifestResponse = await fetch(browserAPI.runtime.getURL(server.manifestUrl));\n      const manifest = await manifestResponse.json();\n\n      // Check if OAuth is required\n      if (manifest.oauth) {\n        console.log('[Directory] Server requires OAuth:', manifest.oauth);\n        if (btn) btn.textContent = 'Authenticating...';\n        \n        // Check if already authenticated\n        const statusResponse = await browserAPI.runtime.sendMessage({\n          type: 'oauth_status',\n          server_id: server.id,\n        });\n        console.log('[Directory] Initial OAuth status:', statusResponse);\n        \n        if (!statusResponse?.ok || !statusResponse.authenticated) {\n          // Need to do OAuth - start the flow\n          console.log('[Directory] Starting OAuth flow...');\n          const flowResponse = await browserAPI.runtime.sendMessage({\n            type: 'oauth_start_flow',\n            provider: manifest.oauth.provider,\n            server_id: server.id,\n            scopes: manifest.oauth.scopes,\n          });\n          console.log('[Directory] OAuth flow response:', flowResponse);\n          \n          if (!flowResponse?.ok) {\n            throw new Error(flowResponse?.error || 'Failed to start OAuth flow');\n          }\n          \n          showToast('Complete sign-in in the new tab...', 'info');\n          \n          // Wait for OAuth to complete (poll for status)\n          console.log('[Directory] Waiting for OAuth completion...');\n          const authenticated = await waitForOAuthCompletion(server.id);\n          console.log('[Directory] OAuth wait result:', authenticated);\n          if (!authenticated) {\n            throw new Error('OAuth authentication was not completed');\n          }\n          \n          showToast('Authentication successful!', 'success');\n        }\n        \n        if (btn) btn.textContent = 'Installing...';\n      }\n\n      // Load the script\n      const scriptUrl = new URL(manifest.scriptUrl, browserAPI.runtime.getURL(server.manifestUrl)).href;\n      const scriptResponse = await fetch(scriptUrl);\n      const scriptText = await scriptResponse.text();\n      \n      const fullManifest = {\n        ...manifest,\n        id: server.id,\n        runtime: 'js',\n        scriptBase64: btoa(unescape(encodeURIComponent(scriptText))),\n      };\n\n      const response = await browserAPI.runtime.sendMessage({\n        type: 'sidebar_install_server',\n        manifest: fullManifest,\n      });\n\n      if (!response?.ok) {\n        throw new Error(response?.error || 'Failed to install server');\n      }\n\n      // Start the server\n      await browserAPI.runtime.sendMessage({\n        type: 'sidebar_validate_server',\n        serverId: server.id,\n      });\n    }\n\n    installedServerIds.add(server.id);\n    showToast(`Installed ${server.name}`, 'success');\n    refreshList();\n  } catch (err) {\n    console.error('[Directory] Failed to install server:', err);\n    showToast(`Failed to install: ${err instanceof Error ? err.message : String(err)}`, 'error');\n    if (btn) {\n      btn.disabled = false;\n      btn.textContent = 'Install';\n    }\n  }\n}\n\n/**\n * Wait for OAuth authentication to complete by polling.\n */\nasync function waitForOAuthCompletion(serverId: string, timeoutMs = 300000): Promise<boolean> {\n  const pollInterval = 2000; // 2 seconds\n  const maxAttempts = timeoutMs / pollInterval;\n  let attempts = 0;\n  \n  console.log(`[Directory] Starting OAuth poll for server: ${serverId}`);\n  \n  while (attempts < maxAttempts) {\n    attempts++;\n    \n    try {\n      const response = await browserAPI.runtime.sendMessage({\n        type: 'oauth_status',\n        server_id: serverId,\n      });\n      \n      console.log(`[Directory] OAuth poll #${attempts} response:`, response);\n      \n      if (response?.ok && response.authenticated) {\n        console.log('[Directory] OAuth completed successfully!');\n        return true;\n      }\n    } catch (err) {\n      console.warn('[Directory] OAuth poll error:', err);\n    }\n    \n    // Wait before next poll\n    await new Promise(resolve => setTimeout(resolve, pollInterval));\n  }\n  \n  console.warn(`[Directory] OAuth polling timed out after ${attempts} attempts`);\n  return false;\n}\n\nasync function uninstallServer(server: BundledServer): Promise<void> {\n  const btn = document.querySelector(`[data-server-id=\"${server.id}\"] .btn`) as HTMLButtonElement;\n  if (btn) {\n    btn.disabled = true;\n    btn.textContent = 'Removing...';\n  }\n\n  try {\n    const response = await browserAPI.runtime.sendMessage({\n      type: 'sidebar_remove_server',\n      serverId: server.id,\n    });\n\n    if (!response?.ok) {\n      throw new Error(response?.error || 'Failed to remove server');\n    }\n\n    installedServerIds.delete(server.id);\n    showToast(`Removed ${server.name}`, 'success');\n    refreshList();\n  } catch (err) {\n    console.error('[Directory] Failed to remove server:', err);\n    showToast(`Failed to remove: ${err instanceof Error ? err.message : String(err)}`, 'error');\n    if (btn) {\n      btn.disabled = false;\n      btn.textContent = 'Uninstall';\n    }\n  }\n}\n\nfunction showToast(message: string, type: 'info' | 'success' | 'error' = 'info'): void {\n  const existing = document.querySelector('.toast');\n  if (existing) existing.remove();\n\n  const toast = document.createElement('div');\n  toast.className = `toast ${type}`;\n  toast.textContent = message;\n  document.body.appendChild(toast);\n\n  setTimeout(() => toast.remove(), 3000);\n}\n\nasync function refreshList(): Promise<void> {\n  // Render immediately, then update installed status\n  renderServerList();\n  \n  // Load installed status in background and re-render\n  try {\n    await loadInstalledServers();\n    renderServerList();\n  } catch (err) {\n    console.error('[Directory] Failed to check server status:', err);\n  }\n}\n\nfunction renderServerList(): void {\n  list.innerHTML = '';\n  \n  if (BUNDLED_SERVERS.length === 0) {\n    const empty = document.createElement('div');\n    empty.className = 'empty-state';\n    empty.innerHTML = `\n      <div class=\"empty-icon\">\uD83D\uDCE6</div>\n      <div class=\"empty-title\">No bundled servers</div>\n      <div class=\"empty-desc\">No MCP servers are bundled with this version of Harbor.</div>\n    `;\n    list.appendChild(empty);\n    return;\n  }\n\n  BUNDLED_SERVERS.forEach((server) => {\n    list.appendChild(renderServerCard(server));\n  });\n}\n\n/**\n * Install a server from a URL.\n */\nasync function installFromUrl(url: string): Promise<void> {\n  if (!url.trim()) {\n    showToast('Please enter a URL', 'error');\n    return;\n  }\n\n  installUrlBtn.disabled = true;\n  installUrlBtn.textContent = 'Loading...';\n\n  try {\n    const result = await loadFromUrl(url);\n    await handleLoadResult(result);\n  } finally {\n    installUrlBtn.disabled = false;\n    installUrlBtn.textContent = 'Install';\n  }\n}\n\n/**\n * Install a server from a File.\n */\nasync function installFromFile(file: File): Promise<void> {\n  showToast(`Loading ${file.name}...`, 'info');\n\n  try {\n    const result = await loadFromFile(file);\n    await handleLoadResult(result);\n  } catch (err) {\n    showToast(`Failed to load file: ${err instanceof Error ? err.message : String(err)}`, 'error');\n  }\n}\n\n/**\n * Handle the result of loading a package.\n */\nasync function handleLoadResult(result: LoadResult): Promise<void> {\n  if (!result.success) {\n    showToast(`Failed to load: ${result.error}`, 'error');\n    return;\n  }\n\n  const manifest = result.manifest;\n  console.log('[Directory] Loaded manifest:', manifest);\n\n  // Check if server is already installed\n  if (installedServerIds.has(manifest.id)) {\n    showToast(`Server \"${manifest.name}\" is already installed`, 'error');\n    return;\n  }\n\n  // Ensure runtime is set\n  if (!manifest.runtime) {\n    if (manifest.scriptBase64 || manifest.scriptUrl) {\n      manifest.runtime = 'js';\n    } else if (manifest.wasmBase64 || manifest.moduleBytesBase64 || manifest.moduleUrl) {\n      manifest.runtime = 'wasm';\n    }\n  }\n\n  // Check for OAuth requirements\n  if (manifest.oauth) {\n    // Check OAuth status\n    try {\n      const response = await browserAPI.runtime.sendMessage({\n        type: 'oauth_status',\n        server_id: manifest.id,\n      });\n      if (!response?.ok || !response.authenticated) {\n        showToast(`Server \"${manifest.name}\" requires OAuth. Sign in first via the OAuth setup flow.`, 'error');\n        return;\n      }\n    } catch {\n      showToast(`Server \"${manifest.name}\" requires OAuth which could not be verified.`, 'error');\n      return;\n    }\n  }\n\n  // Install the server\n  try {\n    const response = await browserAPI.runtime.sendMessage({\n      type: 'sidebar_install_server',\n      manifest,\n    });\n\n    if (!response?.ok) {\n      throw new Error(response?.error || 'Failed to install server');\n    }\n\n    // Start the server to validate it\n    await browserAPI.runtime.sendMessage({\n      type: 'sidebar_validate_server',\n      serverId: manifest.id,\n    });\n\n    installedServerIds.add(manifest.id);\n    showToast(`Installed ${manifest.name}`, 'success');\n    refreshList();\n  } catch (err) {\n    showToast(`Failed to install: ${err instanceof Error ? err.message : String(err)}`, 'error');\n  }\n}\n\n/**\n * Setup drop zone for file upload.\n */\nfunction setupDropZone(): void {\n  if (!dropZone || !fileInput) return;\n\n  // Click to browse\n  dropZone.addEventListener('click', () => fileInput.click());\n\n  // File input change\n  fileInput.addEventListener('change', () => {\n    const file = fileInput.files?.[0];\n    if (file) {\n      installFromFile(file);\n      fileInput.value = ''; // Reset for next use\n    }\n  });\n\n  // Drag and drop events\n  dropZone.addEventListener('dragover', (e) => {\n    e.preventDefault();\n    dropZone.classList.add('dragging');\n  });\n\n  dropZone.addEventListener('dragleave', () => {\n    dropZone.classList.remove('dragging');\n  });\n\n  dropZone.addEventListener('drop', (e) => {\n    e.preventDefault();\n    dropZone.classList.remove('dragging');\n\n    const file = e.dataTransfer?.files?.[0];\n    if (file) {\n      installFromFile(file);\n    }\n  });\n}\n\n/**\n * Setup URL install button.\n */\nfunction setupUrlInstall(): void {\n  if (!installUrlBtn || !installUrlInput) return;\n\n  installUrlBtn.addEventListener('click', () => {\n    installFromUrl(installUrlInput.value);\n  });\n\n  // Install on Enter key\n  installUrlInput.addEventListener('keydown', (e) => {\n    if (e.key === 'Enter') {\n      installFromUrl(installUrlInput.value);\n    }\n  });\n}\n\n// Theme management\ntype Theme = 'light' | 'dark' | 'system';\n\nfunction getSystemTheme(): 'light' | 'dark' {\n  return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n}\n\nfunction applyTheme(theme: Theme): void {\n  const effectiveTheme = theme === 'system' ? getSystemTheme() : theme;\n  document.documentElement.setAttribute('data-theme', effectiveTheme);\n  localStorage.setItem('harbor-theme', theme);\n  updateThemeToggle(theme);\n}\n\nfunction updateThemeToggle(theme: Theme): void {\n  if (!themeToggle) return;\n  const icons: Record<Theme, string> = { light: '\u2600\uFE0F', dark: '\uD83C\uDF19', system: '\uD83D\uDDA5\uFE0F' };\n  themeToggle.textContent = icons[theme];\n  themeToggle.title = `Theme: ${theme} (click to change)`;\n}\n\nfunction initTheme(): void {\n  const saved = localStorage.getItem('harbor-theme') as Theme | null;\n  const theme = saved || 'system';\n  applyTheme(theme);\n\n  // Listen for system theme changes\n  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {\n    const current = localStorage.getItem('harbor-theme') as Theme | null;\n    if (current === 'system' || !current) {\n      applyTheme('system');\n    }\n  });\n\n  // Listen for theme changes from other tabs/windows (sidebar)\n  window.addEventListener('storage', (e) => {\n    if (e.key === 'harbor-theme' && e.newValue) {\n      applyTheme(e.newValue as Theme);\n    }\n  });\n}\n\nfunction cycleTheme(): void {\n  const current = (localStorage.getItem('harbor-theme') as Theme | null) || 'system';\n  const order: Theme[] = ['system', 'light', 'dark'];\n  const next = order[(order.indexOf(current) + 1) % order.length];\n  applyTheme(next);\n}\n\n// Initialize when DOM is ready\nfunction init(): void {\n  console.log('[Directory] Initializing...');\n  console.log('[Directory] list element:', list);\n  console.log('[Directory] BUNDLED_SERVERS:', BUNDLED_SERVERS.length);\n\n  initTheme();\n  themeToggle?.addEventListener('click', cycleTheme);\n\n  // Setup URL and file install handlers\n  setupUrlInstall();\n  setupDropZone();\n\n  if (list) {\n    refreshList().catch((error) => {\n      console.error('[Directory] Failed to load directory:', error);\n    });\n  } else {\n    console.error('[Directory] List element not found!');\n  }\n}\n\n// Run init when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', init);\n} else {\n  init();\n}\n"],
  "mappings": "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",
  "names": []
}
