#!/bin/bash
# Harbor Installer - Post-install setup
# This script runs after files are copied to set up native messaging and Firefox extension

set -e

LOG_FILE="/tmp/harbor-install.log"
echo "Harbor post-install started at $(date)" >> "$LOG_FILE"

# Installation paths
HARBOR_DIR="/Library/Application Support/Harbor"
HARBOR_BIN="$HARBOR_DIR/harbor-bridge"
HARBOR_XPI="$HARBOR_DIR/harbor.xpi"

# =============================================================================
# Select correct binary for current architecture
# =============================================================================
select_binary() {
    echo "Selecting binary for current architecture..."
    
    # Use sysctl to detect native architecture (works even under Rosetta)
    # uname -m can return x86_64 when running under Rosetta on Apple Silicon
    if sysctl -n hw.optional.arm64 2>/dev/null | grep -q "1"; then
        ARCH="arm64"
    else
        ARCH=$(uname -m)
    fi
    echo "  Detected architecture: $ARCH" >> "$LOG_FILE"
    
    if [ "$ARCH" = "arm64" ]; then
        BINARY_SOURCE="$HARBOR_DIR/harbor-bridge-arm64"
    else
        BINARY_SOURCE="$HARBOR_DIR/harbor-bridge-x64"
    fi
    
    if [ -f "$BINARY_SOURCE" ]; then
        # Copy the correct binary
        cp "$BINARY_SOURCE" "$HARBOR_BIN"
        chmod +x "$HARBOR_BIN"
        echo "  ✓ Selected $ARCH binary"
        echo "  Selected binary: $BINARY_SOURCE -> $HARBOR_BIN" >> "$LOG_FILE"
        
        # Clean up both architecture-specific binaries
        rm -f "$HARBOR_DIR/harbor-bridge-arm64" 2>/dev/null || true
        rm -f "$HARBOR_DIR/harbor-bridge-x64" 2>/dev/null || true
    elif [ -f "$HARBOR_BIN" ]; then
        # Single-arch build already has the binary in place
        echo "  ✓ Using pre-built binary"
        echo "  Using pre-built binary at: $HARBOR_BIN" >> "$LOG_FILE"
    else
        echo "  ✗ ERROR: No suitable binary found for $ARCH!" | tee -a "$LOG_FILE"
        exit 1
    fi
}

# Native messaging paths
FIREFOX_NATIVE_HOSTS="/Library/Application Support/Mozilla/NativeMessagingHosts"
CHROME_NATIVE_HOSTS="/Library/Application Support/Google/Chrome/NativeMessagingHosts"
CHROMIUM_NATIVE_HOSTS="/Library/Application Support/Chromium/NativeMessagingHosts"
MANIFEST_NAME="harbor_bridge_host"

# Extension IDs (stamped by build-pkg.sh from credentials.env)
# Firefox extension ID (email format, e.g., "raffi.krikorian.harbor@gmail.com")
EXTENSION_ID="__EXTENSION_ID__"
# Chrome extension ID (32-char string, e.g., "abcdefghijklmnopqrstuvwxyzabcdef")
CHROME_EXTENSION_ID="__CHROME_EXTENSION_ID__"

# Which browsers to install for (set by installer choices)
# Can be: "firefox", "chrome", or "both" (default)
INSTALL_BROWSERS="${INSTALL_BROWSERS:-both}"

# =============================================================================
# Create launcher script
# =============================================================================
create_launcher() {
    echo "Creating launcher script..."
    
    LAUNCHER_SCRIPT="$HARBOR_DIR/harbor-bridge-launcher"
    
    cat > "$LAUNCHER_SCRIPT" << 'LAUNCHER_EOF'
#!/bin/bash
# Harbor Bridge Launcher
# Wrapper script for native messaging

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Suppress Node.js warnings that could corrupt the native messaging protocol
export NODE_NO_WARNINGS=1

# Tell pkg where to find native modules (better-sqlite3)
# The native .node files are in the native/ subdirectory
export PKG_EXECPATH="$SCRIPT_DIR/harbor-bridge"

# Log file for debugging
LOG_FILE="$HOME/.harbor/bridge.log"
mkdir -p "$(dirname "$LOG_FILE")"

# Execute the bridge, redirecting stderr to log file
exec "$SCRIPT_DIR/harbor-bridge" 2>>"$LOG_FILE"
LAUNCHER_EOF

    chmod +x "$LAUNCHER_SCRIPT"
    echo "Launcher script created at: $LAUNCHER_SCRIPT" >> "$LOG_FILE"
}

# =============================================================================
# Install native messaging manifest for Firefox
# =============================================================================
install_firefox_native_manifest() {
    echo "Installing Firefox native messaging manifest..."
    
    # Create directory if it doesn't exist
    mkdir -p "$FIREFOX_NATIVE_HOSTS"
    
    # Get the launcher path
    LAUNCHER_PATH="$HARBOR_DIR/harbor-bridge-launcher"
    
    # Create the system-wide manifest
    MANIFEST_FILE="$FIREFOX_NATIVE_HOSTS/${MANIFEST_NAME}.json"
    
    cat > "$MANIFEST_FILE" << EOF
{
  "name": "$MANIFEST_NAME",
  "description": "Harbor Bridge - AI Agent Platform with MCP Tools",
  "path": "$LAUNCHER_PATH",
  "type": "stdio",
  "allowed_extensions": ["$EXTENSION_ID"]
}
EOF

    echo "Firefox native manifest installed at: $MANIFEST_FILE" >> "$LOG_FILE"
    echo "  ✓ Firefox system manifest: $MANIFEST_FILE"
    
    # Also update user-level manifest if it exists (it takes precedence)
    ACTUAL_USER="${SUDO_USER:-}"
    if [ -z "$ACTUAL_USER" ]; then
        ACTUAL_USER=$(stat -f '%Su' /dev/console 2>/dev/null || echo "")
    fi
    
    if [ -n "$ACTUAL_USER" ] && [ "$ACTUAL_USER" != "root" ]; then
        USER_HOME=$(eval echo "~$ACTUAL_USER")
        USER_MANIFEST="$USER_HOME/Library/Application Support/Mozilla/NativeMessagingHosts/${MANIFEST_NAME}.json"
        
        if [ -f "$USER_MANIFEST" ]; then
            echo "  Found user-level Firefox manifest, updating..."
            cat > "$USER_MANIFEST" << EOF
{
  "name": "$MANIFEST_NAME",
  "description": "Harbor Bridge - AI Agent Platform with MCP Tools",
  "path": "$LAUNCHER_PATH",
  "type": "stdio",
  "allowed_extensions": ["$EXTENSION_ID"]
}
EOF
            chown "$ACTUAL_USER" "$USER_MANIFEST"
            echo "  ✓ Firefox user manifest updated"
        fi
    fi
}

# =============================================================================
# Install native messaging manifest for Chrome/Chromium
# =============================================================================
install_chrome_native_manifest() {
    echo "Installing Chrome native messaging manifest..."
    
    LAUNCHER_PATH="$HARBOR_DIR/harbor-bridge-launcher"
    
    # Chrome extension ID - stamped from credentials.env by build script
    # This is the ID from Chrome Web Store (32 lowercase letters a-p)
    # Leave as placeholder if not yet published to Web Store
    CHROME_EXTENSION_ID="__CHROME_EXTENSION_ID__"
    
    # Skip if no Chrome extension ID configured
    if [ -z "$CHROME_EXTENSION_ID" ] || [ "$CHROME_EXTENSION_ID" = "__CHROME_EXTENSION_ID__" ]; then
        echo "  ⚠ Chrome extension ID not configured (extension not yet in Web Store?)"
        echo "  Native messaging will be configured when CHROME_EXTENSION_ID is set"
        echo "Chrome extension ID not configured, skipping native messaging" >> "$LOG_FILE"
        return 0
    fi
    
    echo "  Chrome extension ID: $CHROME_EXTENSION_ID"
    
    # Install for Google Chrome
    mkdir -p "$CHROME_NATIVE_HOSTS"
    CHROME_MANIFEST="$CHROME_NATIVE_HOSTS/${MANIFEST_NAME}.json"
    
    cat > "$CHROME_MANIFEST" << EOF
{
  "name": "$MANIFEST_NAME",
  "description": "Harbor Bridge - AI Agent Platform with MCP Tools",
  "path": "$LAUNCHER_PATH",
  "type": "stdio",
  "allowed_origins": ["chrome-extension://$CHROME_EXTENSION_ID/"]
}
EOF

    echo "Chrome native manifest installed at: $CHROME_MANIFEST" >> "$LOG_FILE"
    echo "  ✓ Chrome system manifest: $CHROME_MANIFEST"
    
    # Also install for Chromium (same format)
    mkdir -p "$CHROMIUM_NATIVE_HOSTS"
    CHROMIUM_MANIFEST="$CHROMIUM_NATIVE_HOSTS/${MANIFEST_NAME}.json"
    cp "$CHROME_MANIFEST" "$CHROMIUM_MANIFEST"
    echo "  ✓ Chromium system manifest: $CHROMIUM_MANIFEST"
    
    # Update user-level manifests if they exist
    ACTUAL_USER="${SUDO_USER:-}"
    if [ -z "$ACTUAL_USER" ]; then
        ACTUAL_USER=$(stat -f '%Su' /dev/console 2>/dev/null || echo "")
    fi
    
    if [ -n "$ACTUAL_USER" ] && [ "$ACTUAL_USER" != "root" ]; then
        USER_HOME=$(eval echo "~$ACTUAL_USER")
        
        # Chrome user manifest
        USER_CHROME_DIR="$USER_HOME/Library/Application Support/Google/Chrome/NativeMessagingHosts"
        USER_CHROME_MANIFEST="$USER_CHROME_DIR/${MANIFEST_NAME}.json"
        if [ -f "$USER_CHROME_MANIFEST" ]; then
            cp "$CHROME_MANIFEST" "$USER_CHROME_MANIFEST"
            chown "$ACTUAL_USER" "$USER_CHROME_MANIFEST"
            echo "  ✓ Chrome user manifest updated"
        fi
        
        # Chromium user manifest  
        USER_CHROMIUM_DIR="$USER_HOME/Library/Application Support/Chromium/NativeMessagingHosts"
        USER_CHROMIUM_MANIFEST="$USER_CHROMIUM_DIR/${MANIFEST_NAME}.json"
        if [ -f "$USER_CHROMIUM_MANIFEST" ]; then
            cp "$CHROME_MANIFEST" "$USER_CHROMIUM_MANIFEST"
            chown "$ACTUAL_USER" "$USER_CHROMIUM_MANIFEST"
            echo "  ✓ Chromium user manifest updated"
        fi
    fi
}

# =============================================================================
# Install native messaging manifests (wrapper for both browsers)
# =============================================================================
install_native_manifest() {
    echo "Installing native messaging manifests..."
    
    case "$INSTALL_BROWSERS" in
        firefox)
            install_firefox_native_manifest
            ;;
        chrome)
            install_chrome_native_manifest
            ;;
        both|*)
            install_firefox_native_manifest
            install_chrome_native_manifest
            ;;
    esac
}

# =============================================================================
# Install Firefox extension via policy
# =============================================================================
install_firefox_extension() {
    echo "Setting up Firefox extension..."
    
    # Method 1: Try enterprise policies (works on some Firefox installs)
    POLICIES_DIR="/Library/Application Support/Mozilla/policies"
    POLICIES_FILE="$POLICIES_DIR/policies.json"
    
    mkdir -p "$POLICIES_DIR"
    
    # URL-encode the path (spaces -> %20)
    HARBOR_XPI_URL="file://$(echo "$HARBOR_XPI" | sed 's/ /%20/g')"
    
    cat > "$POLICIES_FILE" << EOF
{
  "policies": {
    "Extensions": {
      "Install": [
        "$HARBOR_XPI_URL"
      ]
    },
    "ExtensionSettings": {
      "$EXTENSION_ID": {
        "installation_mode": "normal_installed",
        "install_url": "$HARBOR_XPI_URL"
      }
    }
  }
}
EOF
    echo "  ✓ Firefox policy configured (fallback)"
    
    # Method 2: Open the XPI file to trigger Firefox install prompt
    # Run as the actual user so it opens in their Firefox session
    # Try multiple methods to find the actual user
    ACTUAL_USER="${SUDO_USER:-}"
    if [ -z "$ACTUAL_USER" ]; then
        # Try to get the console user (who is logged in at the GUI)
        ACTUAL_USER=$(stat -f '%Su' /dev/console 2>/dev/null || echo "")
    fi
    if [ -z "$ACTUAL_USER" ]; then
        ACTUAL_USER="$USER"
    fi
    
    echo "  Detected user: $ACTUAL_USER" >> "$LOG_FILE"
    echo "  Detected user: $ACTUAL_USER"
    
    if [ -n "$ACTUAL_USER" ] && [ "$ACTUAL_USER" != "root" ]; then
        echo "  Opening extension in Firefox for user: $ACTUAL_USER"
        echo "  Opening extension in Firefox for user: $ACTUAL_USER" >> "$LOG_FILE"
        
        # Open the XPI file with Firefox - this triggers the install prompt
        # Run in background so it doesn't block the installer
        # Use su to run as the actual user (not root)
        su "$ACTUAL_USER" -c "open -a Firefox '$HARBOR_XPI'" 2>> "$LOG_FILE" &
        
        echo "  ✓ Firefox extension install prompt triggered"
        echo "Extension XPI opened for $ACTUAL_USER" >> "$LOG_FILE"
    else
        echo "  ⚠ Could not determine user (got: '$ACTUAL_USER'), please install extension manually"
        echo "Could not determine user: SUDO_USER='$SUDO_USER' USER='$USER'" >> "$LOG_FILE"
        echo "  Open: $HARBOR_XPI"
    fi
}

# =============================================================================
# Install Chrome extension via Web Store
# =============================================================================
install_chrome_extension() {
    echo "Setting up Chrome extension..."
    
    # Chrome Web Store URL - stamped by build script
    # Format: https://chrome.google.com/webstore/detail/harbor/EXTENSION_ID
    CHROME_WEBSTORE_URL="__CHROME_WEBSTORE_URL__"
    
    # Skip if no Web Store URL configured
    if [ -z "$CHROME_WEBSTORE_URL" ] || [ "$CHROME_WEBSTORE_URL" = "__CHROME_WEBSTORE_URL__" ]; then
        echo "  ⚠ Chrome Web Store URL not configured"
        echo "  For development, load the extension manually:"
        echo "    1. Open Chrome → chrome://extensions/"
        echo "    2. Enable 'Developer mode'"
        echo "    3. Click 'Load unpacked' → select: $HARBOR_DIR/chrome-extension"
        return 0
    fi
    
    # Get the actual user
    ACTUAL_USER="${SUDO_USER:-}"
    if [ -z "$ACTUAL_USER" ]; then
        ACTUAL_USER=$(stat -f '%Su' /dev/console 2>/dev/null || echo "")
    fi
    
    echo "  Opening Chrome Web Store..."
    echo "Chrome Web Store URL: $CHROME_WEBSTORE_URL" >> "$LOG_FILE"
    
    if [ -n "$ACTUAL_USER" ] && [ "$ACTUAL_USER" != "root" ]; then
        # Open Chrome Web Store page to trigger installation
        su "$ACTUAL_USER" -c "open -a 'Google Chrome' '$CHROME_WEBSTORE_URL'" 2>> "$LOG_FILE" &
        echo "  ✓ Chrome Web Store opened"
        echo "  Click 'Add to Chrome' to install the extension"
    else
        echo "  ⚠ Could not determine user, please install manually:"
        echo "    $CHROME_WEBSTORE_URL"
    fi
}

# =============================================================================
# Set permissions
# =============================================================================
set_permissions() {
    echo "Setting permissions..."
    
    # Make the bridge executable
    chmod +x "$HARBOR_BIN"
    
    # Make the uninstall script executable
    if [ -f "$HARBOR_DIR/uninstall.sh" ]; then
        chmod +x "$HARBOR_DIR/uninstall.sh"
    fi
    
    echo "Permissions set" >> "$LOG_FILE"
}

# =============================================================================
# Install uninstaller
# =============================================================================
install_uninstaller() {
    echo "Installing uninstaller..."
    
    # Create CLI symlink
    if [ -d "/usr/local/bin" ]; then
        ln -sf "$HARBOR_DIR/uninstall.sh" "/usr/local/bin/harbor-uninstall"
        echo "  ✓ CLI uninstaller: harbor-uninstall"
    fi
    
    # Create uninstaller app from AppleScript
    # The app is built during the pkg creation, we just copy it
    if [ -d "$HARBOR_DIR/Uninstall Harbor.app" ]; then
        cp -R "$HARBOR_DIR/Uninstall Harbor.app" "/Applications/"
        echo "  ✓ Uninstaller app: /Applications/Uninstall Harbor.app"
    fi
    
    echo "Uninstaller installed" >> "$LOG_FILE"
}

# =============================================================================
# Create first-run marker (as the actual user, not root)
# =============================================================================
create_first_run_marker() {
    # Create a marker file so the extension knows this is a fresh install
    # The extension will check for this and show the welcome page
    
    # Get the actual user (the one who ran sudo)
    ACTUAL_USER="${SUDO_USER:-}"
    if [ -z "$ACTUAL_USER" ]; then
        ACTUAL_USER=$(stat -f '%Su' /dev/console 2>/dev/null || echo "")
    fi
    
    if [ -z "$ACTUAL_USER" ] || [ "$ACTUAL_USER" = "root" ]; then
        echo "Could not determine actual user for marker, skipping" >> "$LOG_FILE"
        return 0
    fi
    
    USER_HOME=$(eval echo "~$ACTUAL_USER")
    MARKER_DIR="$USER_HOME/.harbor"
    
    # Create directory as the actual user
    su "$ACTUAL_USER" -c "mkdir -p '$MARKER_DIR'"
    
    # Only create if it doesn't exist (don't overwrite on upgrades)
    if [ ! -f "$MARKER_DIR/.installed" ]; then
        su "$ACTUAL_USER" -c "cat > '$MARKER_DIR/.installed'" << EOF
first_install=$(date +%s)
show_welcome=true
EOF
        echo "First-run marker created for $ACTUAL_USER" >> "$LOG_FILE"
    else
        echo "Upgrade marker exists for $ACTUAL_USER" >> "$LOG_FILE"
    fi
}

# =============================================================================
# Main installation
# =============================================================================

echo ""
echo "═══════════════════════════════════════════════════════════════"
echo "  Harbor - Post-Installation Setup"
echo "═══════════════════════════════════════════════════════════════"
echo ""

# Run installation steps
select_binary
set_permissions
create_launcher
install_native_manifest
install_firefox_extension
install_chrome_extension
install_uninstaller
create_first_run_marker

CHROME_WEBSTORE_URL="__CHROME_WEBSTORE_URL__"

echo ""
echo "═══════════════════════════════════════════════════════════════"
echo ""
echo "✓ Harbor has been installed successfully!"
echo ""
echo "FIREFOX:"
echo "  Firefox will open with an extension install prompt."
echo "  Click 'Add' to install, then look for ⚓ in the sidebar."
echo ""
echo "  If Firefox doesn't open, manually open this file:"
echo "    $HARBOR_XPI"
echo ""
if [ -n "$CHROME_WEBSTORE_URL" ] && [ "$CHROME_WEBSTORE_URL" != "__CHROME_WEBSTORE_URL__" ]; then
echo "CHROME:"
echo "  Chrome Web Store will open. Click 'Add to Chrome' to install."
echo "  Then click the Harbor icon to open the side panel."
echo ""
else
echo "CHROME (Developer Mode):"
echo "  1. Open Chrome → chrome://extensions/"
echo "  2. Enable 'Developer mode' (top right toggle)"
echo "  3. Click 'Load unpacked'"
echo "  4. Select: $HARBOR_DIR/chrome-extension"
echo "  5. Click the Harbor icon to open the side panel"
echo ""
fi
echo "IMPORTANT: Start Docker Desktop before using MCP servers."
echo ""
echo "To uninstall Harbor later:"
echo "  • Double-click 'Uninstall Harbor' in /Applications"
echo "  • Or run: harbor-uninstall"
echo ""
echo "═══════════════════════════════════════════════════════════════"

echo "Post-install completed successfully at $(date)" >> "$LOG_FILE"
exit 0
